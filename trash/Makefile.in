
CWD := $(dir $(lastword $(MAKEFILE_LIST)))

#  Device-specific Makefile
#
-include $(CWD)Makefile.$(DEVICE)

#  Software-program-specific Makefile
#
ifneq ($(strip $(PROG_SW)),)
  include $(CWD)Makefile.$(PROG_SW)
endif

#  Programming-hardware-specific Makefile
#
#ifneq ($(strip $(PROG_HW)),)
#  include $(CWD)Makefile.$(PROG_HW)
#endif

#	Commands & options
#
CC		= $(ARCH)gcc
AS		= $(ARCH)as
OBJCOPY		= $(ARCH)objcopy
ODUMP		= $(ARCH)objdump
GDB		= $(ARCH)gdb
SIZE		= $(ARCH)size
STD		= c1x

CFLAGS		+= $(MMCU)
CFLAGS		+= -std=$(STD)
CFLAGS		+= -Wall
CFLAGS		+= -Wextra
#CFLAGS		+= -pedantic
CFLAGS		+= -Wpedantic	# GCC 4.8
CFLAGS		+= -fno-diagnostics-show-caret	# GCC 4.8
CFLAGS		+= -ftrack-macro-expansion=0
#CFLAGS		+= -fomit-frame-pointer
CFLAGS		+= -ffunction-sections
#CFLAGS		+= -fno-builtins
CFLAGS		+= -fpack-struct
#CFLAGS		+= -fshort-enums
#CFLAGS		+= -mcall-prologues
CFLAGS		+= -g
#CFLAGS		+= -pipe
CFLAGS		+= -Os
#CFLAGS		+= -O0
#CFLAGS		+= -O1
#CFLAGS		+= -O2
#CFLAGS		+= -O3
CFLAGS		+= $(DEFINES)
CFLAGS		+= $(INCLUDES)

AFLAGS		+= $(MMCU)
AFLAGS		+= -Wall
#AFLAGS		+= -Wextra
AFLAGS		+= $(DEFINES)
AFLAGS		+= $(INCLUDES)


LDFLAGS		+= $(MMCU)
#LDFLAGS		+= -s
LDFLAGS		+= -Wl,-Map,$(OBJDIR)/$(OUT).map,--cref
#LDFLAGS		+= -Wl,-u,vfprintf -lprintf_min
#LDFLAGS		+= -nostartfiles
LDFLAGS		+= -Wl,--gc-sections
#LDFLAGS		+= -nostdlib # Provide clear_bss aso
#LDFLAGS		+= -Wl,--section-start=.protext=0x1E00
#LDFLAGS		+= -Wl,--section-start=.bss.pro=0x800100
#LDFLAGS		+= -L/usr/lib/avr/lib
#LDFLAGS		+= -L/home/indy/dev/avr/toolchain/current/install/avr/lib
#LDFLAGS		+= -lm


#ODUMPFLAGS	= -S
ODUMPFLAGS	= -h -S
#ODUMPFLAGS	= -D


#	Build object files list from source files list
#
OBJECTS		 = $(SOURCES:.c=.$(DEVICE).o)
OBJECTS		:= $(OBJECTS:.sx=.$(DEVICE).o)
OBJECTS		:= $(addprefix $(OBJDIR)/,$(OBJECTS))


hex:	$(OBJDIR)/$(OUT).hex
bin:	$(OBJDIR)/$(OUT).bin
lst:	$(OBJDIR)/$(OUT).lst


#  Compute size (and CRC) of the generated binary
#
.PHONY: size
size:	$(OBJDIR)/$(OUT).bin
	$(SIZE) $^
	@diabolo.py --crc $(OBJDIR)/$(OUT).bin | cut -d',' -f3


#  PADTO is used to fill unused flash memory space with 0xFF bytes
#
ifneq ($(strip $(DEVICE_FLASH_SIZE)),)
  PADTO = --pad-to $(DEVICE_FLASH_SIZE)
else
  PADTO =
endif


#	Preprocess
#
%.cp.c: %.c
	$(CPP) $(CFLAGS) $< >$@
#	$(CPP) $(CFLAGS) $< |sed -e 's/;/;\n/g'|bcpp -s -i 2 -bcl | sed -e 's/#/\/\//g' > $@

%.cp.s: %.s
	$(CPP) $(AFLAGS) $< >$@

%.cp.sx: %.sx
	$(CPP) $(AFLAGS) $< >$@
	if grep '\.fail' $@ ; then exit 1 ; fi
	if grep '#error' $@ ; then exit 1 ; fi

%.s : %.c
	$(CC) $(MMCU) -std=c99 -Wall -Wextra -Os -c -g -S $< -o $@


#	Compile and link
#
$(OBJECTS): | $(OBJDIR) $(INC_HWA)		# Create directory if needed

$(OBJDIR):
	@mkdir $(OBJDIR)


$(OBJDIR)/%.$(DEVICE).o : %.c
	@echo "RULE: $@: $^"
	$(CC) $(CFLAGS) -c $< -o $@

$(OBJDIR)/%.o : %.c
	@echo "RULE: $@: $^"
	$(CC) $(CFLAGS) -c $< -o $@

$(OBJDIR)/%.$(DEVICE).o : %.s
	@echo "RULE: $@: $^"
	$(AS) $(AFLAGS) $< -o $@

$(OBJDIR)/%.o : %.s
	@echo "RULE: $@: $^"
	$(AS) $(AFLAGS) $< -o $@

# $(OBJDIR)/%.$(MCU).o : %.sx Makefile
# 	grep '\.fail' $< && $(CC) $(AFLAGS) -c $< -o $@
# $(OBJDIR)/%.o : %.sx Makefile
# 	$(CC) $(AFLAGS) -c $< -o $@

$(OBJDIR)/%.$(DEVICE).o : %.cp.sx
	@echo "RULE: $@: $^"
	$(CC) $(AFLAGS) -c $< -o $@

# $(OBJDIR)/%.$(MCU).o : %.sx
# 	$(CC) $(AFLAGS) -c $< -o $@

# $(OBJDIR)/%.o : %.cp.sx
# 	if grep '\.fail' $< ; then exit1 ; else exit 0 ; fi
# 	$(AS) $(AFLAGS) -o $@ $<

$(OBJDIR)/$(OUT).elf : $(OBJECTS) $(LDSCRIPT)
	@echo "RULE: $@: $^"
	$(CC) $(LDFLAGS) -o $@ $(OBJECTS) $(LIBS)


#	Post-linking
#
%.bin : %.elf
	$(OBJCOPY) -R .eeprom -O binary --gap-fill=0xFF $(PADTO) $^ $@

%.hex : %.elf
	$(OBJCOPY) --gap-fill=0xFF -R .eeprom -O ihex $^ $@

%.lst : %.elf
	$(ODUMP) $(ODUMPFLAGS) $^ >$@
