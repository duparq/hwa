
	;; -*- asm -*-

	;; UART synchronization:	u16 sync_10_1 ( void )
	;; 
	;; Returns the number of SYSHZ cycles for 1 bit (R25:R24)
	;; 
	;; Determines baudrate by measuring the low-level durations of a 10 bits
	;; low / 1 bit low sequence.
	;; 
	;; Consecutive low-level durations t1 and t2 are measured.
	;; When 9.5×t2 <= t1 <= 10.5×t2, synchronization is done
	;; and R25:R24 contains the bit duration (baudrate) in CPU cycles.
	;;
	;; Measures are done with 16 bit counters of 5 SYSHZ cycles units. This
	;; means that the longest low-level duration must be lower than 65535*5 =
	;; 327675 cycles. With 10 low-level bits characters, this routine can not
	;; synchronize at speeds below SYSHZ/32767 bps.
	;;
	;; Notes:
	;; 
	;;   FT232R seems to have a bug under Linux-3.0: at 1 kbps, random
	;;   duration of 10 bits low!
	;; 
	;; Tests:
	;; 
	;;   8 MHz / 1200 bps:
	;;    1 bit = 833µs =  6667 cycles = 1333 units
	;;    10 bits =  units
	;;    t1 = 13316, t2 = 1331, t = 6658
	;; 
	;;   8 MHz / 2400 bps
	;;    1 bit = 417µs = 3333 cycles = 667 units
	;;    10 bits = 6667 units
	;;    t1 = 6658, t2 = 682, t = 3329
	;;
	;;   8 MHz / 19200 bps
	;;    1 bit = 52.1µs = 417 cycles = 83 units
	;;    10 bits = 833 units
	;;    t1 = 832, t2 = 83, t = 416
	;;
	;;   8 MHz / 115200 bps
	;;    1 bit = 8.68µs = 69.4 cycles = 13.89 units
	;;    10 bits = 139 units
	;;    t1 = , t2 = , t = 70


	;; GCC call-used registers: R18..R27, R30, R31 (these registers can be
	;; used freely by the callee)


	;; Init last measure t2 to 0
	;; 
	ldi	R24, 0
	ldi	R25, 0

	;; Shift measures
	;; 
1:	movw	R18, R24	;		t1 = t2
	ldi	R24, 0		;		t2 = 0
	ldi	R25, 0		;

	.if DBG_SYNC1
	XSB	r26, DBGPIN, DBGBIT
	.endif

	;; Measure next low-level duration in t2 (R25:R24)
	;; 
2:	sbis	RXDPIN, RXDBIT	;		Wait RXD == 1
	.if DBG_SYNC2
	XSB	r26, DBGPIN, DBGBIT
	.endif
	rjmp	2b		;

2:	sbic	RXDPIN, RXDBIT	; [1/2]		Wait RXD == 0
	.if DBG_SYNC2
	XSB	r26, DBGPIN, DBGBIT
	.endif
	rjmp	2b		; [2]

2:	adiw	R24, 1		; [2]	|	Compute low level duration
	sbis	RXDPIN, RXDBIT	; [1/2]	|	in 5 CPU cycles units
	rjmp	2b		; [2]	|= 5

	;; Compute R27:R26 = 10×t2
	;; 
	movw	R26, R24	; R27:R26 = t2
	lsl	R26		;
	rol	R27		; R27:R26 = 2×t2
	lsl	R26		;
	rol	R27		; R27:R26 = 4×t2
	add	R26, R24	;
	adc	R27, R25	; R27:R26 = 5×t2
	lsl	R26		;
	rol	R27		; R27:R26 = 10×t2

	;; Compute R31:R30 = dt = t2/2
	;; 
	movw	R30, R24	; R31:R30 = t2
	adiw	R30, 1		; round
	lsr	R31		;
	ror	R30		; R31:R30 = t2/2
	
	;; Compute R27:R26 = 10×t2 - dt
	;; 
	sub	R26, R30	;
	sbc	R27, R31	; R27:R26 = 10×t2 - dt

	;; Check the lower bound
	;; 
	cp	R18, R26	; if ( t1 < 10×t2 - dt )
	cpc	R19, R27	;   then t1 is too low
	brcs	1b		;   loop to get another sample

	;; Compute R27:R26 = 10×t2 + dt
	;; 
	add	R26, R30	;
	adc	R27, R31	; R27:R26 = 10×t2
	add	R26, R30	;
	adc	R27, R31	; R27:R26 = 10×t2 + dt

	;; Check the upper bound
	;; 
	cp	R18, R26	; if ( t1 > 10×t2 + dt )
	cpc	R19, R27	;   then t1 is too high
	brcc	1b		;   loop to get another sample

	;; Store result
	;;
	;; t1 is duration of 10 low-level bits in units of 5 SYSHZ cycles.
	;; So, t1/2 is duration of 5 low-level bits in units of 5 SYSHZ cycles,
	;; that is the duration of 1 low-level bit in units of 1 SYSHZ cycles.
	;; 
	movw	R24, R18	; R25:R24 = t1
	adiw	R24, 1		; round
	lsr	R25
	ror	R24		; R25:R24 = t1/2 = bit duration
