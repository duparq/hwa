
	;; -*- asm -*-

	;; Set dtn and dt0 in SYSHZ cycles according to counter clock divisor
	;; and computed delays
	;;
	;;	R25:R24 = dtn in cpu cycles
	;;

	NSHIFTS = 99

	.if PSC == 1
	NSHIFTS=0
	.endif

	.if PSC == 8
	NSHIFTS=3
	.endif

	.if PSC == 32
	NSHIFTS=5
	.endif

	.if PSC == 64
	NSHIFTS=6
	.endif

	.if PSC == 256
	NSHIFTS=8
	.endif

	.if NSHIFTS == 99
	.error "Invalid prescaler setting."
	.endif

	.section	.text.setdt,"ax",@progbits
setdt:
	.if NSHIFTS
#if defined SWUART_PIN_RX
	movw	R26, R24
#endif
	rcall	doshift
	.endif

	;; Store dtn
	;;
	sts	dtn+0, R24

	;; .if COUNT_BN==8 && MATCH_BN==16
	;; ;;
	;; ;; dtn+1 is decremented first in the ISR
	;; ;; so we must first increment it here
	;; ;; 
	;; inc	R25
	;; .endif

	.if MATCH_BN==16
	sts	dtn+1, R25
	.endif

#if defined SWUART_PIN_RX
	;;
	;; Compute dt0 = dtn + dtn/2 - dtn/8 - delay (cpu cycles)
	;;
	DELAY=TSTART1+TBITRX1+1
	.if PSC > 1
	movw	R24, R26
	.endif
	movw	R26, R24	; R25:R24 = dtn in cpu cycles
	adiw	R26, 1		; round
	lsr	R27
	ror	R26
	add	R24, R26
	adc	R25, R27
	adiw	R26, 2 		; round
	lsr	R27
	ror	R26
	lsr	R27
	ror	R26
	sub	R24, R26
	.if MATCH_BN==16
	sbc	R25, R27
	.endif
	subi	R24, (DELAY & 0xFF)
	.if MATCH_BN==16
	sbci	R25, (DELAY >> 8)
	.endif

	.if PSC > 1
	rcall	doshift
	.endif

	;; Store dt0
	;; 
	sts	dt0+0, R24
	.if MATCH_BN==16
	sts	dt0+1, R25
	.endif
#endif
	ret


	.section	.text.doshift,"ax",@progbits
doshift:
	;; Convert dtn in timer prescaled units
	;;
	;; Round
	;;
	.if NSHIFTS
	adiw	R24, PSC/2
	.endif

	;; Compute dtn/PSC
	;; 
	.if NSHIFTS>0 && NSHIFTS<8
	ldi	R18, NSHIFTS
1:	lsr	R25
	ror	R24
	dec	R18
	brne	1b
	.endif

	.if NSHIFTS==8
	mov	R24, R25
	ldi	R25, 0
	.endif

	ret
