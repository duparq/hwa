
	;; -*- asm -*-

	;; Full software half-duplex autobaud UART without interrupts
	;; 
	;; -*- Last modified: 2013-09-19 08:46:00 -*-

	;; Broches utilisées
	;;
	;; .equ	RXD, 2		; RXD == PB2 (7)
	;; .equ	TXD, 0		; TXD == PB0 (5)
	;; .equ	DBG, 1		; DBG == PB1 (6)


	;; RX and TX pins
	;;
	.equ	TXDPORT, PORTB
	.equ	TXDBIT,  0

	.equ	RXDPORT, PORTB
	.equ	RXDBIT,  0


	;; I/O registers
	;; 
	.equ	TXDDR, TXDPORT-1
	.equ	RXDPIN, RXDPORT-2
	.if	TXDPORT == RXDPIN+2 && TXDBIT == RXDBIT
	.equ	ONEWIRE, 1
	.else
	.equ	ONEWIRE, 0
	.endif


	.section .bss

	.global	swuart0_T
swuart0_T:
	.word	0		; Durée d'un bit


	.section .text


	;; Calcule la durée d'un bit : swuart0_T	(R18--R26)
	;; en nombre de cycles SYSHZ
	;;
	.global swuart0_syn
	.section	.text.swuart0_syn,"ax",@progbits
swuart0_syn:
	ldi	R18, 0xFF	; t1 = 65535
	ldi	R19, 0xFF
	ldi	R20, 0		; tn = 0
	ldi	R21, 0

1:	ldi	R24, 0		; Mesure état bas dans R25:R24
	ldi	R25, 0
2:	sbis	RXDPIN, RXDBIT	;		Attend RXD == 1
	rjmp	2b		;
2:	sbic	RXDPIN, RXDBIT	; [1/2]		Attend RXD == 0
	rjmp	2b		; [2]
2:	adiw	R24, 1		; [2]	|	Chronomètre
	sbis	RXDPIN, RXDBIT	; [1/2]	|
	rjmp	2b		; [2]	|= 5

	cp	R24, R18	; SI t < t1
	cpc	R25, R19
	brcc	2f
	movw	R18, R24	; ALORS t1 = t

2:	cp	R20, R24	; SI tn < t
	cpc	R21, R25
	brcc	2f
	movw	R20, R24	; ALORS tn = t

2:	movw	R24, R18
	sbiw	R24, 1		; (t1-1)
	movw	R22, R24

.if 1
	ldi	R26, 3
2:	lsl	R24		; × 8
	rol	R25
	dec	R26
	brne	2b
.else
	lsl	R24		; × 8
	rol	R25
	lsl	R24
	rol	R25
	lsl	R24
	rol	R25
.endif

	add	R24, R22	; + (t1-1)
	adc	R25, R23

	cp	R24, R20	; SI 9×(t1-1) >= tn
	cpc	R25, R21
	brcc	1b		; ALORS boucle

	adiw	R24, 18		; SI 9×(t1+1) < tn
	cp	R24, R20
	cpc	R25, R21
	brcs	3f		; ALORS peut-être 10 bits
	add	R20, R18
	adc	R21, R19
	rjmp	4f

3:	add	R24, R22	; + (t1+1)
	adc	R25, R23
	adiw	R24, 2
	cp	R24, R20	; SI 10×(t1+1) < tn
	cpc	R25, R21
	brcs	swuart0_syn	; ALORS recommencer tout
	
4:	lsr	R21
	ror	R20
	sts	swuart0_T, R20
	sts	swuart0_T+1, R21
	ret


	;; Temporisation R25:R24 + 7 cycles			(R24, R25)
	;; 3 + 4 (n-1) + 3 + 4 = 6 + 4 n
	;; 
delay:				; [3] rcall
	sbiw	R24, 4		; [2]   |
	brcc	delay		; [2/1] |= 4
	ret			; [4]

	;; Emission d'un caractère dans R24	 		(R24--R27)
	;;
	.global swuart0_putbyte
	.section	.text.swuart0_putbyte,"ax",@progbits
swuart0_putbyte:
	.if ONEWIRE
	sbi	TXDPORT, TXDBIT	; Initialise TXD
	sbi	TXDDR, TXDBIT	;
	.endif
	ldi	R26, 10		; nbits = 1 start + 8 data + 1 stop
	mov	R27, R24
	com	R27		; Inverse l'octet (optimisation)
	sec			; Prépare le bit de START
1:	brcc	2f		; [1/2]	|	SI CARRY
	cbi	TXDPORT, TXDBIT	; [1]   |	ALORS envoie '0'
	rjmp	3f		; [2]	|
2:	sbi	TXDPORT, TXDBIT	; [1]   |	SINON envoie '1'
	nop			; [1]	|
3:	lds	R24, swuart0_T	; [2]	|
	lds	R25, swuart0_T+1; [2]	|
	sbiw	R24, 10+2+6+4	; [2]	|= 10
	rcall	delay
	lsr	R27		; [1]	|	Bit suivant
	dec	R26		; [1]	|
	brne	1b		; [2]	|= 4	Jusqu'au dernier
	.if ONEWIRE
	cbi	TXDPORT, TXDBIT	; Dé-initialise TXD
	cbi	TXDDR, TXDBIT	;
	.endif
	ret

	;; Réception d'un octet dans R24		(R22--R27)
	;;
	.global swuart0_getbyte
	.section	.text.swuart0_getbyte,"ax",@progbits
swuart0_getbyte:
	ldi 	R22, 9		; 8 data bits + 1 stop bit
1:	sbis	RXDPIN, RXDBIT	;	Attend RXD == 1
	rjmp	1b
1:	sbic 	RXDPIN, RXDBIT	; [1/2] Attend RXD == 0
	rjmp 	1b		; [2]

	lds	R24, swuart0_T	; [2]	|	Délai bit start + 1/2 bit
	lds	R25, swuart0_T+1; [2]	|
	movw	R26, R24	; [1]	|
	lsr	R25		; [1]	|
	ror	R24		; [1]	|
	add	R24, R26	; [1]	|
	adc	R25, R27	; [1]	|
	sbiw	R24, 11+0+6	; [2]	|= 11
	rcall	delay

;; 1:	sbi	PINB, DBG	; [2]   |
1:	in	R24, RXDPIN	; [1]	|	Échantillonne le bit
	bst	R24, RXDBIT	; [1]	|	dans T
	dec 	R22		; [1]   |	SI dernier
	breq 	1f		; [1/2] |	ALORS sortir
	lsr 	R23		; [1]   |	Range le bit
	bld	R23, 7		; [1]	|
	lds	R24, swuart0_T	; [2]	|
	lds	R25, swuart0_T+1; [2]	|
	sbiw	R24, 14+4+6+2	; [2]	|= 14
	rcall	delay
	rjmp 	1b		; [2]   	Bit suivant
1:	ldi	R25, 0		;		R25 à 0 (à FF après delay)
	bld	R25, 0		;		Bit de stop dans R25.0
	mov	R24, R23	;		Octet reçu dans R24
	ret
