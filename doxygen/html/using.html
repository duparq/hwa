<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>HWA: Using HWA</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extrastylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">HWA
   </div>
   <div id="projectbrief">HardWare Abstractor</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('using.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Using HWA </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>First of all, in order to use the HWA facilities, the symbol <code>HW_DEVICE</code> must be defined with the name of the target device before <code>hwa.h</code> is included:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define HW_DEVICE   attiny44</span></div>
<div class="line"><span class="preprocessor">#include &lt;hwa.h&gt;</span></div>
</div><!-- fragment --><p>See the device-specific documentation for the <code>HW_DEVICE</code> definition to use with each supported device.</p>
<h2>Instructions </h2>
<p>HWA uses two kinds of instructions:</p>
<ul>
<li>synchronous instructions, with <code>hw_</code> prefix</li>
<li>asynchronous instructions, with <code>hwa_</code> prefix</li>
</ul>
<p>Synchronous instructions produce an immediate action.</p>
<p>Asynchronous instructions can only be used after an <code>hwa_begin()</code> or <code>hwa_begin_from_reset()</code> instruction. Their action is memorized into the HWA cache. When the <code>hwa_commit()</code> instruction is met, HWA determines from the content of the cache the machine code to produce.</p>
<p>The <code>hwa_nocommit()</code> instruction can be used to put the cache in a known state without producing machine code. This can be used to make HWA produce code that modifies a known configuration.</p>
<h2>Object names </h2>
<p>Almost all instructions use an object name as first argument. All object names are lower cased.</p>
<p>Object names always begin with <code>hw_</code> and always end with a number: <code>hw_counter1</code>, <code>hw_uart0</code>, <code>hw_pcic2</code>...</p>
<p>Pin names always begin with <code>hw_pin_</code>: <code>hw_pin_pa0</code>, <code>hw_pin_pb4</code>...</p>
<p>Pin numbers (<code>hw_pin_1</code>...) can be used if <code>HW_DEVICE_PACKAGE</code> is defined:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define HW_DEVICE          attiny44</span></div>
<div class="line"><span class="preprocessor">#define HW_DEVICE_PACKAGE  dil</span></div>
</div><!-- fragment --><p>Most HWA instructions are generic and accept objects of various classes as first parameter. This allows writing less verbose code and makes it easier to replace an object by another, or port the code to a different target device. Several instructions accept a variable length list of parameters consisting of key/value pairs.</p>
<h2>Instructions that act on hardware </h2>
<table class="doxtable">
<tr>
<th>Synchronous </th><th>Asynchronous </th><th>Action  </th></tr>
<tr>
<td><code>hw_config(...)</code> </td><td><code>hwa_config(...)</code> </td><td>Configure an object. </td></tr>
<tr>
<td><code>hw_clear(...)</code> </td><td><code>hwa_clear(...)</code> </td><td>Clear an object. </td></tr>
<tr>
<td><code>hw_read(...)</code> </td><td></td><td>Read an object. </td></tr>
<tr>
<td><code>hw_read_reg(...)</code> </td><td></td><td>Short for <code>hw_read(hw_reg(...))</code> </td></tr>
<tr>
<td><code>hw_atomic_read(...)</code> </td><td></td><td>Disable interrupts while reading an object. </td></tr>
<tr>
<td><code>hw_stat(...)</code> </td><td></td><td>Get the status of an object. </td></tr>
<tr>
<td><code>hw_toggle(...)</code> </td><td><code>hwa_toggle(...)</code> </td><td>Toggle an object (probably an output pin). </td></tr>
<tr>
<td><code>hw_trigger(...)</code> </td><td><code>hwa_trigger(...)</code> </td><td>Trigger an object (A/D converter, compare unit...) </td></tr>
<tr>
<td><code>hw_turn(...)</code> </td><td><code>hwa_turn(...)</code> </td><td>Turn on object on/off. </td></tr>
<tr>
<td><code>hw_turn_irq(...)</code> </td><td><code>hwa_turn_irq(...)</code> </td><td>Enable/disable an IRQ. </td></tr>
<tr>
<td><code>hw_stat_irq(...)</code> </td><td></td><td>Get the status of an IRQ flag. </td></tr>
<tr>
<td><code>hw_write(...)</code> </td><td><code>hwa_write(...)</code> </td><td>Write something into an object. </td></tr>
<tr>
<td><code>hw_write_reg(...)</code> </td><td><code>hwa_write_reg(...)</code></td><td>Short for <code>hwa_write(hw_reg(...), value)</code> </td></tr>
</table>
<h2>Instructions that do not act on hardware </h2>
<p>HWA provides a few instructions that give informations about objects without accessing the hardware. These instructions can be used in assembler programming.</p>
<table class="doxtable">
<tr>
<th>Instruction </th><th>Result  </th></tr>
<tr>
<td><code>hw_reg(...)</code> </td><td>Definition of a register (a set of bits) of an object. </td></tr>
<tr>
<td><code>hw_rt(...)</code> </td><td>Type of one object's register (uint8_t, uint16_t...) </td></tr>
<tr>
<td><code>hw_addr(...)</code> </td><td>Address (of a register, group of bits...). </td></tr>
<tr>
<td><code>hw_bn(...)</code> </td><td>Number of bits (of a register, group of bits, counter...) </td></tr>
<tr>
<td><code>hw_bp(...)</code> </td><td>Position of least significant bit of a group of bits. </td></tr>
<tr>
<td><code>hw_ap(...)</code> </td><td>Address, position of the least significant bit (for assembler programming) </td></tr>
<tr>
<td><code>hw_id(...)</code> </td><td>Id of an object </td></tr>
<tr>
<td><code>hw_io(...)</code> </td><td>I/O name associated to an object </td></tr>
<tr>
<td><code>hw_sub(...)</code> </td><td>Sub (relative) object of an object </td></tr>
<tr>
<td><code>hw_sup(...)</code> </td><td>Parent object of an object </td></tr>
</table>
<h1>General purpose macros </h1>
<h2>Errors </h2>
<table class="doxtable">
<tr>
<th>Macro </th><th>Result  </th></tr>
<tr>
<td><code>HW_ERR(msg)</code> </td><td>Produce an error message at preprocessing time </td></tr>
<tr>
<td><code>HWA_ERR(msg)</code> </td><td>Produce an error message after the code generation is finished </td></tr>
</table>
<h2>List processing </h2>
<table class="doxtable">
<tr>
<th>Macro </th><th>Result  </th></tr>
<tr>
<td><code>HW_A0(a0,...)</code> </td><td>Expansion of a0 </td></tr>
<tr>
<td><code>HW_A1(a0,a1,...)</code> </td><td>Expansion of a1 </td></tr>
<tr>
<td><code>HW_A2(a0,a1,a2,...)</code> </td><td>Expansion of a2 </td></tr>
<tr>
<td><code>HW_G2(a0,a1,...)</code> </td><td>Expansions of a0 and a1 glued with a '_' between </td></tr>
<tr>
<td><code>HW_G3(a0,a1,a2,...)</code> </td><td>Expansions of a0, a1, and a2 glued with a '_' between </td></tr>
</table>
<h1>Interrupts </h1>
<p>Interrupts are HWA objects. The definition of an interrupt is used when you need to enable, disable or clear an interrupt request or for declaring an interrupt service routine (ISR).</p>
<p>You obtain the definition of an interrupt with the instruction <code>hw_irq( controller [, interrupt_name] )</code>.</p>
<p>Use the <code>hw/hwa_turn(...)</code> or <code>hw/hwa_turn_irq(...)</code> instruction to enable/disable an interrupt request:</p>
<div class="fragment"><div class="line">foo()</div>
<div class="line">{</div>
<div class="line">  hwa_begin();</div>
<div class="line">  hwa_turn( hw_irq(hw_counter1, overflow), on ); <span class="comment">// Enable counter1 overflow irqs</span></div>
<div class="line">  hwa_turn_irq( hw_counter1, input0, off );      <span class="comment">// Disable counter1 input capture irqs</span></div>
<div class="line">  hwa_commit();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Interrupt service routines are declared with the <code>HW_ISR( hw_irq(...) )</code> statement:</p>
<div class="fragment"><div class="line">HW_ISR( hw_irq( hw_counter1, overflow ) )</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// code to handle the overflow of the counting register</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>The <code>HW_ISR(...)</code> macro also accepts that you provide the parameters of <code>hw_irq(...)</code> directly:</p>
<div class="fragment"><div class="line">HW_ISR( hw_counter1, capture0 )</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// code to handle the capture event of Counter/Timer1</span></div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line">HW_ISR( hw_watchdog0 )</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// code to handle the overflow of the watchdog timer</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Optionnal parameter <code>isr_interruptible</code> can be added to make the ISR interruptible.</p>
<p>Optionnal parameter <code>isr_naked</code> can be used to have a naked body for your ISR e.g. if you are sure that no register will be altered:</p>
<div class="fragment"><div class="line">HW_ISR( hw_counter0, overflow, isr_naked )</div>
<div class="line">{</div>
<div class="line">  hw_toggle( hw_pin_pa0 ); <span class="comment">// will use the `sbi` instruction, no register is altered</span></div>
<div class="line">  hw_reti();               <span class="comment">// produce the `reti` instruction</span></div>
<div class="line">}</div>
</div><!-- fragment --><h1>See also </h1>
<ul>
<li><a class="el" href="atmelavr_devices.html">Atmel AVR devices</a> </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
