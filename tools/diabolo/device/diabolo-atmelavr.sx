
	;; -*- asm -*-

	;; Diabolo Is A BOotLOader
	;; 
	;; 1 or 2-wire serial link without timer nor interrupts
	;; initialized at Power-On Reset or Watchdog reset

	;; Macros for extended instructions
	;; 
	.include "atmelavr-xinstr.sx"

	;; Notes:
	;; 
	;; * could spare a few bytes by removing page programming verification
	;; (then diabolo.py would do it).

	;; Pins: PIN_RXD and PIN_TXD can be the same
	;;
	RXDPORT   = hw_addr(hw_reg(hw_ctr(PIN_RXD), port))
	RXDPIN    = hw_addr(hw_reg(hw_ctr(PIN_RXD), pin))
	RXDDR     = hw_addr(hw_reg(hw_ctr(PIN_RXD), ddr))
	RXDBP     = hw_bp(PIN_RXD)

	TXDPORT   = hw_addr(hw_reg(hw_ctr(PIN_TXD), port))
	TXDDR     = hw_addr(hw_reg(hw_ctr(PIN_TXD), ddr))
	TXDBP     = hw_bp(PIN_TXD)

	X_ONEWIRE = (hw_id(PIN_RXD)==hw_id(PIN_TXD))

	;;  Registers
	;;
	MCUSR     = hw_addr(hw_reg(hw_core0, mcusr))
	WDTCSR    = hw_addr(hw_reg(hw_watchdog0, csr))
	SPMCSR    = hw_addr(hw_reg(hw_flash0, csr))
	EEARL     = hw_addr(hw_reg(hw_eeprom0, arl))
	EEARH     = hw_addr(hw_reg(hw_eeprom0, arh))
	EEDR      = hw_addr(hw_reg(hw_eeprom0, dr))
	EECR      = hw_addr(hw_reg(hw_eeprom0, cr))

#define AP_EEMPE    hw_ap(hw_reg(hw_eeprom0, mpe))
#define AP_EEPE     hw_ap(hw_reg(hw_eeprom0, pe))
#define AP_EERE     hw_ap(hw_reg(hw_eeprom0, re))


#if defined PIN_DBG
	DBG = 1

	DBGPORT   = hw_addr(hw_reg(hw_ctr(PIN_DBG), port))
	DBGPIN    = hw_addr(hw_reg(hw_ctr(PIN_DBG), pin))
	DBGDR     = hw_addr(hw_reg(hw_ctr(PIN_DBG), ddr))
	DBGBIT    = hw_bp(PIN_DBG)

	.macro dbg x
	.if \x
	sbi	DBGPORT, DBGBIT
	.else
	cbi	DBGPORT, DBGBIT
	.endif
	.endm
#else
	DBG = 0
	.macro dbg x
	.endm
#endif


	;; Constants
	;;
	PROTOCOL  = 3
	BLPAGES   = 12

	PAGESIZE  = HW_DEVICE_PAGESIZE          ; from HWA
	RAMSTART  = HW_DEVICE_RAMSTART          ;
	RAMSIZE   = HW_DEVICE_RAMSIZE           ;
	FLASHSIZE = HW_DEVICE_FLASHSIZE         ;
	SIGNATURE0 = HW_A0(HW_DEVICE_SIGNATURE) ;
	SIGNATURE1 = HW_A1(HW_DEVICE_SIGNATURE) ;
	SIGNATURE2 = HW_A2(HW_DEVICE_SIGNATURE) ;

	RAMEND    = (RAMSTART + RAMSIZE - 1)
	FLASHEND  = (FLASHSIZE - 1)
	APPSTART  = HW_DEVICE_NVECTORS*2

	;; Data in EEPROM
	;;
	;; App CRC is stored MSB first in EEPROM because it must be
	;; sent to the CRC algorithm in this order for checking
	;; 
	EEPCNT = HW_DEVICE_EEPROMSIZE-4 ; 32 bit programmings count (MSB first)
	EECRC  = EEPCNT-4		; 16 bits application CRC (MSB first)

	;; Global variables registers
	;;
	;; R1:R0      written into flash programming buffer
	;; R3:R2      application CRC
	;; R5:R4      RAMSTART
	;; R7         0 if application CRC is valid
	;; R8         MCU status at reset (MCUSR)
	;; R9         OSCCAL value at reset
	;; R11:R10    CRC 16 bits (CCITT) of last transfered packet
	;; R15:R14    UART bit duration in cycles
	;; 
	;; R16        general usage
	;; R17        FF if all application bytes are FF, general usage
	;; R18        virgin page received
	;; R19        virgin page
	;; R22        UART bits counter, page byte counter
	;; R23        UART received byte buffer
	;; R24        UART rx/tx byte
	;; R29:R28    Y: RAM address, Z backup
	;; R31:R30    Z: flash address counter (LPM/SPM)


	;; Change MCU speed macros
	;;
	.if X_SPD
	.macro HSPD reg
	ldi	\reg, 0xFF	; Highest clock speed
	XST	OSCCAL, \reg
	.endm
	.macro NSPD
	XST	OSCCAL, R9	; Revert to factory MCU clock speed
	.endm
	.else
	.macro HSPD reg
	.endm
	.macro NSPD
	.endm
	.endif


	;; /********************************/
	;; /*            START             */
	;; /********************************/

	;; Put the RESET vector in section .init1 so that it will not be removed
	;; by the optimizer
	;; 
	.section .init1
	rjmp	start

	;; Diabolo entry point
	;; 
	;;   The .org directive does not set the address, it advances it!
	;;
	.section .text
	.org FLASHSIZE - PAGESIZE*BLPAGES -2, 0xFF ; Subtract 2 bytes of initial rjmp

start:	XLD	R8, MCUSR	; Store CPU status into R8 before touching it
	ldi	R16, 0x18	; Stop the watchdog
	ldi	R17, 0		;
	XST	MCUSR, R17	; "To clear WDE, WDRF must be cleared first."
	XST	WDTCSR, R16	;
	XST	WDTCSR, R17	;

	.if X_SPD
	XLD	R9, OSCCAL	; Store factory clock speed
	HSPD	R24		; Highest clock speed
	.endif

	.if DBG
	XSB	R24, DBGPORT, DBGBIT
	XSB	R24, DBGDDR, DBGBIT
	.endif
	
	ldi	R16, lo8(RAMSTART)
	ldi	R17, hi8(RAMSTART)
	movw	R4, R16		; R4 = RAMSTART

	;; Compute application CRC from end to begin, ignoring last 0xFF bytes,
	;; while checking RXD level
	;; 
	;; Cycles = 48*nbytes = ~ 3 ms/KiB of flash code
	;;
appcrc:	ldi	R16, 0xFF	;	R16==0xFF while RXD==0
	ldi	R17, 0xFF	;	R17==0xFF while bytes read are 0xFF
	movw	R10, R16	;	Init CRC to 0xFFFF
	ldi	R30, lo8(start) ;	Begin from end of app code
	ldi	R31, hi8(start)	;
1:	sbiw	R30, 1		; [2]
	sbic	RXDPIN, RXDBP	; [2]	Clear R16 if RXD == 1
	clr	R16		; [1]
	lpm	R24, Z		; [3]
	and	R17, R24	; [1]
	cpi	R17, 0xFF	; [1] Do not compute 0xFF bytes at end of app section
	breq	2f		; [1]
	clr	R17		; [1]
	rcall	crcadd		; [30]
2:	cpi	R31, 0		; [1]
	brne	1b		; [2]
	cpi	R30, 2		; [1]
	brne	1b		; [2]=48

	;; Store application CRC in R3:R2 and check against value stored in EEPROM
	;; Store CRC status in R7 (R7==0 if application CRC is OK)
	;; 
	movw	R2, R10
	ldi	R30, lo8(EECRC)
	ldi	R31, hi8(EECRC)
	rcall	eerd
	rcall	eerd

	;; Do not start the application if Diabolo was not started by RESET
	;; (or if it is not the first time this is checked)
	;;
	mov	R18, R8
	andi	R18, 0x07
	breq	init

	;; Do not start the application if its CRC is wrong (R7 != 0)
	;; or all bytes read were 0xFF (R17==0xFF)
	;; or RXD remained 0 while computing CRC (R16==0xFF)
	;;
	or	R16, R10
	or	R16, R11
	or	R16, R17
	brne	init

	;; Start application
	;; 
appstart:
	rjmp	APPSTART-2	; Subtract 2 bytes of initial rjmp

init:	tst	R8		; if not the first time we're here
	breq	error		;   -> error (get '\n' and give prompt)
	clr	R8

	;; This is the first time init is launched
	;;   synchronize UART
	;;     compute bit duration in SYSHZ cycles units
	;;     store it in R15:R14
	;;
sync:	.include "diabolo-atmelavr-sync-10-1.sx"
	movw	R14, R24

	;; Wait end of byte and 1 more byte
	;;   If RXD goes low, re-sync
	;;
	ldi	R20, 20		; 20 bits
1:	movw	R24, R14	;
	rcall	delay		;
	dec	R20		;
	sbic	RXDPIN, RXDBP	; if RXD is low
	brne	1b		;
	brne	sync		;   -> sync again

	;; Initialize UART TX pin
	;; 
	.if	X_ONEWIRE == 0
	sbi	TXDPORT, TXDBP
	sbi	TXDDR, TXDBP
	.endif

	;; Wait for '\n' before giving prompt
	;;
error:	ldi	R24, '!'
	rcall	putbytenocrc
	rcall	getbyte
	cpi	R24, '\n'
	brne	error

	;; Main loop:
	;;   send prompt
	;;   wait for a character command
	;;   process command
	;;
prompt:	ldi	R24, '#'	; 0x23
	rcall	putbytenocrc
	ldi	R24, 0xFF
	mov	R10, R24	; Initialise le CRC communication (0xFFFF)
	mov	R11, R24
	rcall	getbyte

	;; 'i' : identification
	;;    This resets the current address (R31:R30) to 0x0000
	;; 
	cpi	R24, 'i'
	brne	1f

	ldi	R24, PROTOCOL	; 0: protocol
	rcall	putbyte
	ldi	R24, SIGNATURE0	; 1-3: signature
	rcall	putbyte
	ldi	R24, SIGNATURE1
	rcall	putbyte
	ldi	R24, SIGNATURE2
	rcall	putbyte
	ldi	R24, lo8(start)	; 4: bootloader address (LSB)
	rcall	putbyte
	ldi	R24, hi8(start)	; 5: bootloader address (MSB)
	rcall	putbyte
	mov	R24, R3		; 6: application CRC (MSB)
	rcall	putbyte
	mov	R24, R2		; 7: application CRC (LSB)
	rcall	putbyte

	clr	R31		;  8: 0x0000: Fuses low byte
	clr	R30		;  9: 0x0001: Lock bits
2:	ldi	R24, 9		; 10: 0x0002: Fuses extended byte
	XST	SPMCSR, R24	; 11: 0x0003: Fuses high byte
	lpm	R24, Z+
	rcall	putbyte
	cpi	R30, 4
	brne	2b
	clr	R30

crcprompt:
	mov	R24, R11	; CRC (msb)
	rcall	putbytenocrc
	mov	R24, R10	; CRC (lsb)
	rcall	putbytenocrc
	rjmp	prompt

	
	;; 'A' : Set address (-> R31:R30)
	;;
1:	cpi	R24, 'A'
	brne	1f
	rcall	getbyte
	mov	R31, R24	; R31 = MSB
	rcall	getbyte
	mov	R30, R24	; R30 = LSB
	rcall	chkcrc
	brne	error
	rjmp	prompt


	;; 'f': read flash page at Z=R31:R30
	;; 
1:	cpi	R24, 'f'
	brne	1f

	ldi	R20, PAGESIZE
2:	lpm	R24, Z+		; read flash byte
	rcall	putbyte		; send it
	dec	R20
	brne	2b		; until end of page
	rjmp	crcprompt


	;; 'e': lecture EEPROM
	;; 
1:	cpi	R24, 'e'
	brne	1f

	rcall	getbyte		; Nb octets à lire
	mov	R20, R24
2:	rcall	eerd 		; Read EEPROM and add to CRC
	rcall	putbytenocrc
	dec	R20
	brne	2b		; Jusqu'au dernier
	rjmp	crcprompt


	;; 'E' : programmation EEPROM
	;; 
1:	cpi	R24, 'E'
	brne	1f

	rcall	getbyte		; Nb octets
	mov	R20, R24
	mov	R21, R24
	rcall	getbuf
	brne	pdone
	NSPD			; Factory clock speed

	movw	R28, R4		; Y = RAMSTART
2:	sbic	AP_EEPE		; Attend fin écriture en cours
	rjmp	2b
	ldi	R24, 0		; Command: erase & write
	XST	EECR, R24
	XST	EEARL, R30
	XST	EEARH, R31
	ld	R24, Y+
	XST	EEDR, R24
	adiw	R30, 1
	sbi	AP_EEMPE
	sbi	AP_EEPE
	dec	R21
	brne	2b

	HSPD	R24		; Highest clock speed
	ldi	R24, 0x03	; Code 'ERASED' + 'PROGRAMMED'

	;; End of programming
	;;   R24 holds the result code
	;;   Return to prompt
	;; 
pdone:	rcall	putbytenocrc
	rjmp	prompt


	;; Programmation FLASH
	;;
1:	cpi	R24, 'F'
	breq	pflash


	;; Lance l'application
	;; 
1:	cpi	R24, 'X'
	brne	1f
	rcall	chkcrc
	breq	2f
	rjmp	error
2:	ldi	R24, '#'
	rcall	putbytenocrc

	.if	X_ONEWIRE == 0
	ldi	R24, 0		; Désinitialise les ports
	XST	TXDDR, R24
	XST	TXDPORT, R24
	.endif

;; 	rjmp	APPSTART	; Erroneous address with ATtiny84, avr-as bug?
;;
;; 1e84:	79 cf       	rjmp	.-270    	; 0x1d78 <swuart_sync_10_1+0x22>

	rjmp	appstart	; use a trampoline


	;; Go re-compute application CRC
	;; and wait for '\n'
	;;
1:	rjmp	appcrc



	;; Programmation FLASH
	;;   copie les données de la page en RAM
	;;   sinon le temps disponible est insuffisant
	;;
pflash:	ldi	R20, PAGESIZE
	rcall	getbuf		; Receive buffer + CRC
 	brne	pdone		; Bad buffer -> pdone

	;; Check programming address validity: page-aligned & before Diabolo
	;;
	ldi	R24, 0x40	; Error code 'BAD ADDRESS'
	movw	R28, R30	; R29:R28 = Z
	subi	R28, lo8(start)
	sbci	R29, hi8(start)
	brcc	pdone
	andi	R28, PAGESIZE-1
	brne	pdone

	;; Write first two bytes of flash memory (reset vector):
	;;     RJMP to Diabolo: 1100 kkkk kkkk kkkk
	;;
	sbiw	R30, 0
	brne	2f
	ldi	R24, lo8((FLASHSIZE-BLPAGES*PAGESIZE)/2-1 + 0xC000)
	sts	RAMSTART+0, R24
	ldi	R24, hi8((FLASHSIZE-BLPAGES*PAGESIZE)/2-1 + 0xC000)
	sts	RAMSTART+1, R24

2:	ldi	R24, 0x11	; Clear flash programming buffer
	XST	SPMCSR, R24	;
	ldi	R24, 0		; Code 'NO ERROR'
	ldi	R18, 0xFF	; Received page virginity
	ldi	R19, 0xFF	; Current page virginity
	ldi	R20, 0xFF	; Pages equality

	movw	R28, R4		; Y = RAMSTART
	ldi	R22, PAGESIZE/2
2:	ld	R12, Y+		; Received byte
	lpm	R13, Z+		; Original byte

	and	R18, R12	; Update received page virginity
	and	R19, R13	; Update current page virginity
	cpse	R12, R13	; Update pages equality
	ldi	R20, 0		;

	mov	R0, R1		; Build couple of bytes R1:R0 for SPM
	mov	R1, R12		;
	sbrc	R30, 0		;   2 bytes
	rjmp	2b		;

	sbiw	R30, 2		; 2 bytes back
	ldi	R21, 0x01	; Store R1:R0 in page programming buffer
	XST	SPMCSR, R21	;
	spm			;
	adiw	R30, 2		;

	dec	R22		; Repeat until end of page
	brne	2b		;

	cpi	R20, 0xFF	; Go to pdone if page is unchanged
	brne	4f		;
99:	rjmp	pdone		;

4:	subi	R30, PAGESIZE	; Back to start of page's address
	sbci	R31, 0		;

	;; Erase page if not virgin
	;;
	NSPD			; Revert to factory MCU clock speed
	cpi	R19, 0xFF	;
	breq	4f		;
	ori	R24, 0x11	; Load error code: 'ERASED'+'PROGRAMMING ERROR'
	ldi	R21, 0x03	;
	XST	SPMCSR, R21	;
	spm			; Erase page

	;; Program page if received page is not virgin
	;; 
4:	cpi	R18, 0xFF	;
	breq	4f		; 
	ori	R24, 0x12	; Load error code: 'PROGRAMMED'+'PROGRAMMING ERROR'
	;; NSPD			; Revert to factory MCU clock speed
	ldi	R21, 0x05	;
	XST	SPMCSR, R21	;
	spm			; Program page

	;; Verify page content
	;;
4:	HSPD	R28		; Highest clock speed
	movw	R28, R4		; Y pointe le début de la page en RAM
	ldi	R22, PAGESIZE
2:	ld	R12, Y+		; Received byte
	lpm	R13, Z+		; Programmed byte
	cp	R12, R13
	brne	99b
	dec	R22
	brne	2b		;
	andi	R24, ~0x10	; Clear error code 'PROGRAMMING ERROR'
	rjmp	pdone

	;; Get R20 bytes stored in RAM, + CRC16
	;; Return with Z=1 if CRC is valid
	;;
getbuf:	movw	R28, R4		; RAMSTART
1:	rcall	getbyte
	st	Y+, R24
	dec	R20
	brne	1b

	;; Receive and check CRC
	;; Load '\x80' (CRC error) into R24
	;; Return with Z=1 if CRC is valid (== 0)
	;; 
chkcrc:	rcall	getbyte		; Receive CRC
	rcall	getbyte		;
	mov	R24, R10	; Check CRC
	or	R24, R11	; Z=1 if CRC is valid
	ldi	R24, 0x80	; 'CRC error' code, Z unmodified
	ret

	
	;; Read EEPROM : R24 = *(Z++)
	;; 
eerd:	sbic	AP_EEPE
	rjmp	eerd
	XST	EEARL, R30 
	XST	EEARH, R31
	sbi	AP_EERE
	XLD	R24, EEDR
	adiw	R30, 1
	rjmp	crcadd

	;; Delay R25:R24 + 6 cycles			(R24, R25)
	;; 3 + 4 (n/4-1) + 3 + 4 = 6 + n
	;; 
delay:				; [3] rcall
	sbiw	R24, 4		; [2]   |
	brcc	delay		; [2/1] |= 4
	ret			; [4]


	;; Receive one byte in R24			R22, R23, R24, R25
	;; 						R10, R11, R18, R19
	;;
getbyte:
	ldi 	R22, 9		; 8 data bits + 1 stop bit
1:	sbis	RXDPIN, RXDBP	;	Wait RXD == 1
	rjmp	1b
1:	sbic 	RXDPIN, RXDBP	; [1/2] Wait RXD == 0
	rjmp 	1b		; [2]

	movw	R24, R14	; [1]	|	Delay 1+1/2 bit (skip start)
	lsr	R25		; [1]	|
	ror	R24		; [1]	|
	add	R24, R14	; [1]	|
	adc	R25, R15	; [1]	|
	sbiw	R24, 7+6	; [2]	|=7
	rcall	delay

1:	XLD	R24, RXDPIN	; [1]	|	Sample one bit in T
	bst	R24, RXDBP	; [1]	|
	dec 	R22		; [1]   |
	breq 	1f		; [1/2] |	IF last THEN break
	lsr 	R23		; [1]   |	Store T into byte buffer
	bld	R23, 7		; [1]	|
	movw	R24, R14	; [1]	|
	sbiw	R24,  9+4+6+2	; [2]	|=9	FIXME: +4 ?
	rcall	delay
	rjmp 	1b		; [2]   	Next bit
;; 1:	brtc	sync		; [1]		Stop bit == 0 -> resynchronise/restart
1:	mov	R24, R23	; [1]		Store received byte in R24

	;; Update CRC (R11:R10) with byte R24
	;; 						R10, R11, R18, R19
	;;
crcadd:				; [4] (call)
	mov	R19, R24	; [1] Copie

	mov	R18, R10	; [1] CRC = CRC>>8 | CRC<<8
	mov	R10, R11	; [1]
	mov	R11, R18	; [1]

	eor	R10, R19	; [1] CRC ^= byte

	mov	R18, R10	; [1] CRC = CRC ^ ((CRC & 0xFF) >> 4)
	swap	R18		; [1]
	andi	R18, 0x0F	; [1]
	eor	R10, R18	; [1]

	mov	R18, R10	; [1] CRC = CRC ^ ((CRC << 8) << 4)
	swap	R18		; [1]
	andi	R18, 0xF0	; [1]
	eor	R11, R18	; [1]

	mov	R18, R10	; [1] CRC = CRC ^ (((CRC & 0xFF) << 4) << 1)
	swap	R18		; [1]
	mov	R19, R18	; [1]
	andi	R18, 0xF0	; [1]
	andi	R19, 0x0F	; [1]
	lsl	R18		; [1]
	rol	R19		; [1]
	eor	R10, R18	; [1]
	eor	R11, R19	; [1]
	ret			; [4]=30


	;; Send one byte (R24, destroyed)
	;; Update CRC (initialized at 0xFFFF after prompt)
	;;
	;; 						R10, R11, R18, R19, R24, R25, R26, R27
	;;
putbyte:
	rcall	crcadd

	;;						R24, R25, R26, R27
	;; 
putbytenocrc:
	.if X_ONEWIRE
	sbi	TXDPORT, TXDBP	; Setup TXD
	sbi	TXDDR, TXDBP	;
	.endif
	ldi	R26, 10		; nbits = 1 start + 8 data + 1 stop
	mov	R27, R24
	com	R27		; Complement byte (optimization)
	sec			; Load start bit
1:	brcc	2f		; [1/2]	|	IF CARRY
	cbi	TXDPORT, TXDBP	; [1]   |	THEN send '0'
	rjmp	3f		; [2]	|
2:	sbi	TXDPORT, TXDBP	; [1]   |	ELSE send '1'
	nop			; [1]	|
3:	movw	R24, R14	; [1]	|
	sbiw	R24, 7+2+6+4	; [2]	|=7	FIXME: +2 ?
	rcall	delay
	lsr	R27		; [1]	|	Next bit
	dec	R26		; [1]	|
	brne	1b		; [2]	|=4	Repeat until last bit
	.if X_ONEWIRE
	cbi	TXDDR, TXDBP	;
	cbi	TXDPORT, TXDBP	; Release TXD
	.endif
	ret
