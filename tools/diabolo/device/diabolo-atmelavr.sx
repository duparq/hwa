
	;; -*- asm -*-

	;; Diabolo Is A BOotLOader
	;; 
	;; 1 or 2-wire serial link without timer nor interrupts
	;; initialized at Power-On Reset or Watchdog reset

	;; Operations:
	;;
	;;   Identify: 'i'
	;;   Set address: 'A' + addr + CRC
	;;   Read flash page: 'f'
	;;   Write flash page: 'F' + data + CRC
	;;   Read n eeprom bytes: 'e' + n
	;;   Write n eeprom bytes: 'E' + n + bytes + CRC

#if !defined HW_DEVICE_ATTINYX4 && !defined HW_DEVICE_ATMEGAX8
#  error Device is not supported
#endif

	;; Registers
	;;
	;; R1:R0      value written into flash programming buffer
	;; R3:R2      CRC of application
	;; R5:R4      RAMSTART (used to store incomming data)
	;; R7         0 if CRC of application is valid
	;; R8         MCU status at reset (MCUSR)
	;; R9         OSCCAL value at reset
	;; R11:R10    CRC 16 bits (CCITT) of last transfered packet
	;; R15:R14    UART bit duration in cycles
	;; R16        general usage
	;; R17        FF if all application bytes are FF, general usage
	;; R18        virgin page received, CRC computation
	;; R19        virgin page, CRC computation
	;; R20        page equality
	;; R21        
	;; R22        UART bits counter, page byte counter
	;; R23        UART received byte buffer
	;; R24        UART rx/tx byte
	;; R29:R28    Y: RAM address, Z backup
	;; R31:R30    Z: flash address counter (LPM/SPM)


	;; Returned error codes
	;; 
	CODE_NONE = 0
	CODE_ECRC = (1<<7)	; CRC error
	CODE_EAD  = (1<<6)	; Address error
	CODE_EPRG = (1<<4)	; Programming error
	CODE_WRT  = (1<<1)	; Write operation done
	CODE_ERS  = (1<<0)	; Erase operation done


	;; Macros for extended instructions
	;; 
	.include "atmelavr-xinstr.sx"

	;; Notes:
	;; 
	;; * could spare a few bytes by removing page programming verification
	;; (then diabolo.py would do it).

	;; Pins: PIN_RXD and PIN_TXD can be the same
	;;
	RXDPORT   = hw_addr(hw_reg(hw_sup(PIN_RXD), port))
	RXDPIN    = hw_addr(hw_reg(hw_sup(PIN_RXD), pin))
	RXDDR     = hw_addr(hw_reg(hw_sup(PIN_RXD), ddr))
	BP_RXD    = hw_bp(PIN_RXD)
#define AP_RXD    hw_addr(hw_reg(hw_sup(PIN_RXD), pin)), hw_bp(PIN_RXD)

	TXDPORT   = hw_addr(hw_reg(hw_sup(PIN_TXD), port))
	TXDDR     = hw_addr(hw_reg(hw_sup(PIN_TXD), ddr))
	BP_TXD    = hw_bp(PIN_TXD)

	X_ONEWIRE = (hw_id(PIN_RXD)==hw_id(PIN_TXD))

	;;  Registers
	;;
	MCUSR     = hw_addr(hw_reg(hw_core0, mcusr))
	WDTCSR    = hw_addr(hw_reg(hw_watchdog0, csr))

#define RA_WDCE     hw_addr(hw_reg(hw_watchdog0, wdce))
#define RA_WDE      hw_addr(hw_reg(hw_watchdog0, wde))
#if RA_WDCE != RA_WDE
# error
#endif
#define BP_WDCE     hw_bp(hw_reg(hw_watchdog0, wdce))
#define BP_WDE      hw_bp(hw_reg(hw_watchdog0, wde))

	SPMCSR    = hw_addr(hw_reg(hw_flash0, csr))

#if defined HW_DEVICE_ATTINYX4
#  define BP_CTPB     hw_bp(hw_reg(hw_flash0, ctpb))
#elif defined HW_DEVICE_ATMEGAX8
#  define BP_RWWSRE   hw_bp(hw_reg(hw_flash0, rwwsre))
#  define BP_BLBSET   hw_bp(hw_reg(hw_flash0, blbset))
#endif
#define BP_PGWRT    hw_bp(hw_reg(hw_flash0, pgwrt))
#define BP_PGERS    hw_bp(hw_reg(hw_flash0, pgers))
#define BP_SPMEN    hw_bp(hw_reg(hw_flash0, spmen))

	EEARL     = hw_addr(hw_reg(hw_eeprom0, arl))
	EEARH     = hw_addr(hw_reg(hw_eeprom0, arh))
	EEDR      = hw_addr(hw_reg(hw_eeprom0, dr))
	EECR      = hw_addr(hw_reg(hw_eeprom0, cr))

#define AP_EEMPE    hw_ap(hw_reg(hw_eeprom0, mpe))
#define AP_EEPE     hw_ap(hw_reg(hw_eeprom0, pe))
#define AP_EERE     hw_ap(hw_reg(hw_eeprom0, re))


#if defined PIN_DBG
	DBG = 1

	DBGPORT   = hw_addr(hw_reg(hw_sup(PIN_DBG), port))
	DBGPIN    = hw_addr(hw_reg(hw_sup(PIN_DBG), pin))
	DBGDDR    = hw_addr(hw_reg(hw_sup(PIN_DBG), ddr))
	DBGBIT    = hw_bp(PIN_DBG)

	.macro dbg x
	.if \x
	sbi	DBGPORT, DBGBIT
	.else
	cbi	DBGPORT, DBGBIT
	.endif
	.endm
#else
	DBG = 0
	.macro dbg x
	.endm
#endif

	;; Constants
	;;
	PROTOCOL  = 3
	PAGESIZE  = HW_DEVICE_FLASH_PAGE_SIZE   ; from HWA
	FLASHSIZE = HW_DEVICE_FLASH_SIZE        ;
	RAMSTART  = HW_DEVICE_RAM_START         ;
	RAMSIZE   = HW_DEVICE_RAM_SIZE          ;
	SIGNATURE0 = HW_A0(HW_DEVICE_SIGNATURE) ;
	SIGNATURE1 = HW_A1(HW_DEVICE_SIGNATURE) ;
	SIGNATURE2 = HW_A2(HW_DEVICE_SIGNATURE) ;

#if !defined HW_DEVICE_BOOTSECTION_SIZE
	;; Allocate enough pages for Diabolo
	;; 
	BOOTSTART = FLASHSIZE - 12*PAGESIZE
	APPSTART  = HW_DEVICE_APP_START-2
#else
	;; Diabolo in boot section
	;; 
	BOOTSTART = FLASHSIZE - HW_DEVICE_BOOTSECTION_SIZE
	APPSTART  = HW_DEVICE_APP_START
#endif

	;; RAMEND    = (RAMSTART + RAMSIZE - 1)
	;; FLASHEND  = (FLASHSIZE - 1)
	;; APPSTART  = HW_DEVICE_NVECTORS*2
	;; APPSTART  = HW_DEVICE_APP_START

	;; Data in EEPROM
	;;
	;; App CRC is stored MSB first in EEPROM because it must be
	;; sent to the CRC algorithm in this order for checking
	;; 
	EEPCNT = HW_DEVICE_EEPROM_SIZE-4 ; 32 bit programmings count (MSB first)
	EECRC  = EEPCNT-4		 ; 16 bits application CRC (MSB first)

	;; Change MCU speed macros
	;;
#if defined XSPEED
	.macro SPEED_1 reg
	ldi	\reg, 0xFF	; Highest clock speed
	XST	OSCCAL, \reg
	.endm
	.macro SPEED_0
	XST	OSCCAL, R9	; Revert to factory MCU clock speed
	.endm
#else
	.macro SPEED_1 reg
	.endm
	.macro SPEED_0
	.endm
#endif


	;; Macros for flash memory programming
	;;
#if defined HW_DEVICE_ATTINYX4
	.macro	FLASH_CLRBUF
	XLD	R21, 1<<BP_RWWSRE | 1<<BP_SPMEN
	XST	SPMCSR, R21
	spm
	.endm

	.macro	FLASH_LDBYTE
	XLD	R21, 1<<BP_SPMEN
	XST	SPMCSR, R21
	spm
	.endm

	.macro	FLASH_PGERS
	XLD	R21, 1<<BP_PGERS | 1<<BP_SPMEN
	XST	SPMCSR, R21
	spm
	.endm

	.macro	FLASH_PGWRT
	XLD	R21, 1<<BP_PGWRT | 1<<BP_SPMEN
	XST	SPMCSR, R21
	spm
	.endm

#elif defined HW_DEVICE_ATMEGAX8
	.macro	FLASH_CLRBUF
	XLD	R21, 1<<BP_RWWSRE | 1<<BP_SPMEN
	rcall	dospm
	.endm

	.macro	FLASH_LDBYTE
	XLD	R21, 1<<BP_SPMEN
	XST	SPMCSR, R21
	spm
	.endm

	.macro	FLASH_PGERS
	XLD	R21, 1<<BP_PGERS | 1<<BP_SPMEN
	rcall	dospm
	.endm

	.macro	FLASH_PGWRT
	XLD	R21, 1<<BP_PGWRT | 1<<BP_SPMEN
	rcall	dospm
	.endm

	.macro	FLASH_ERWWS
	XLD	R21, 1<<BP_RWWSRE | 1<<BP_SPMEN ; Re-enable RWW section
	rcall	dospm
	.endm
#endif


	;; /********************************/
	;; /*            START             */
	;; /*                              */
	;; /*     Diabolo entry point      */
	;; /*                              */
	;; /********************************/

	;; Put the entry point in section .init1 so that it will not be removed
	;; by the optimizer!

#if defined HW_DEVICE_ATTINYX4
	;; 
	;; Device without boot section: RESET vector = jump to Diabolo
	;;
	.section .init1
	rjmp	start

	;; The .org directive does not set the address, it advances it, so we
	;; must subtract the 2 bytes allocated for the rjmp instruction above
	;;
	.section .text /* Useful? */
	.org BOOTSTART-2, 0xFF

#elif defined HW_DEVICE_ATMEGAX8
	;; 
	;; Device with boot section: this is where Diabolo is installed
	;;
	.section .init1
	.org BOOTSTART, 0xFF
#endif

start:
	;; SP points to RAMEND after reset, non initialization required.

	;; FIXME: maybe should return to the application in case of watchdog reset

	XLD	R8, MCUSR	; Store CPU status into R8 before touching it
	ldi	R16, 1<<BP_WDCE | 1<<BP_WDE ; Stop the watchdog
	ldi	R17, 0		;
	XST	MCUSR, R17	; "To clear WDE, WDRF must be cleared first."
	XST	RA_WDE, R16	; WARNING: does not only write WDCE/WDE
	XST	RA_WDE, R17	; WARNING: does not only write WDCE/WDE

#if defined XSPEED
	XLD	R9, OSCCAL	; Store factory clock speed
	SPEED_1	R24		; Highest clock speed
#endif

	.if DBG
	XSB	R24, DBGPORT, DBGBIT
	XSB	R24, DBGDDR, DBGBIT
	.endif
	
	ldi	R16, lo8(RAMSTART)
	ldi	R17, hi8(RAMSTART)
	movw	R4, R16		; R4 = RAMSTART

	;; Compute application CRC from end to begin, ignoring last 0xFF bytes,
	;; while checking RXD level
	;; 
	;; Cycles = 48*nbytes = ~ 3 ms/KiB of flash code @8MHz
	;;
appcrc:	ldi	R16, 0xFF	;	R16==0xFF while RXD==0
	ldi	R17, 0xFF	;	R17==0xFF while bytes read are 0xFF
	movw	R10, R16	;	Init CRC to 0xFFFF
	ldi	R30, lo8(start) ;	Begin from end of app code
	ldi	R31, hi8(start)	;
1:	sbiw	R30, 1		; [2]
	sbic	RXDPIN, BP_RXD	; [2]	Clear R16 if RXD == 1
	clr	R16		; [1]
	lpm	R24, Z		; [3]
	and	R17, R24	; [1]
	cpi	R17, 0xFF	; [1] Do not compute 0xFF bytes at end of app section
	breq	2f		; [1]
	clr	R17		; [1]
	rcall	crcadd		; [30]
2:	cpi	R31, 0		; [1]
	brne	1b		; [2]
	cpi	R30, 2		; [1]
	brne	1b		; [2]=48

	;; Store application CRC in R3:R2 and check against value stored in EEPROM
	;; Store CRC status in R7 (R7==0 if application CRC is OK)
	;; 
	movw	R2, R10
	ldi	R30, lo8(EECRC)
	ldi	R31, hi8(EECRC)
	rcall	eerd
	rcall	eerd

	;; Do not start the application if Diabolo was not started by RESET
	;; (or if it is not the first time this is checked)
	;;
	mov	R18, R8
	andi	R18, 0x07
	breq	init

	;; Do not start the application if its CRC is wrong (R7 != 0)
	;; or all bytes read were 0xFF (R17==0xFF)
	;; or RXD remained 0 while computing CRC (R16==0xFF)
	;;
	or	R16, R10
	or	R16, R11
	or	R16, R17
	brne	init

	;; Start application
	;; 
appstart:
	;; rjmp	APPSTART-2	; Subtract 2 bytes of initial rjmp
	.if FLASHSIZE <= 4096
	rjmp	APPSTART
	.else
	jmp	APPSTART
	.endif

init:	tst	R8		; if not the first time we're here
	breq	error		;   -> error (get '\n' and give prompt)
	clr	R8

	;; This is the first time init is launched
	;;   synchronize UART
	;;     compute bit duration in SYSHZ cycles units
	;;     store it in R15:R14
	;;
sync:
#include "diabolo-atmelavr-sync-10-1.sx"
	movw	R14, R24

	;; Wait end of byte and 1 more byte
	;;   If RXD goes low, re-sync
	;;
	ldi	R20, 20		; 20 bits
1:	movw	R24, R14	;
	rcall	delay		;
	dec	R20		;
	sbic	RXDPIN, BP_RXD	; if RXD is low
	brne	1b		;
	brne	sync		;   -> sync again

	;; Initialize UART TX pin
	;; 
	.if	X_ONEWIRE == 0
	sbi	TXDPORT, BP_TXD
	sbi	TXDDR, BP_TXD
	.endif

	;; Wait for '\n' before giving prompt
	;;
error:	ldi	R24, '!'
	rcall	putbytenocrc
	rcall	getbyte
	cpi	R24, '\n'
	brne	error

	;; Main loop:
	;;   send prompt
	;;   wait for a character command
	;;   process command
	;;
prompt:	ldi	R24, '#'	; 0x23
	rcall	putbytenocrc
	ldi	R24, 0xFF
	mov	R10, R24	; Initialise le CRC communication (0xFFFF)
	mov	R11, R24
	rcall	getbyte

	;; 'i' : identification
	;;    This resets the current address (R31:R30) to 0x0000
	;; 
	cpi	R24, 'i'
	brne	1f

	ldi	R24, PROTOCOL	; 0: protocol
	rcall	putbyte
	ldi	R24, SIGNATURE0	; 1-3: signature
	rcall	putbyte
	ldi	R24, SIGNATURE1
	rcall	putbyte
	ldi	R24, SIGNATURE2
	rcall	putbyte
	ldi	R24, lo8(start)	; 4: bootloader address (LSB)
	rcall	putbyte
	ldi	R24, hi8(start)	; 5: bootloader address (MSB)
	rcall	putbyte
	mov	R24, R3		; 6: application CRC (MSB)
	rcall	putbyte
	mov	R24, R2		; 7: application CRC (LSB)
	rcall	putbyte

	clr	R31				;  8: 0x0000: Fuses low byte
	clr	R30				;  9: 0x0001: Lock bits
2:	ldi	R24, 1<<BP_BLBSET | 1<<BP_SPMEN	; 10: 0x0002: Fuses extended byte
	XST	SPMCSR, R24			; 11: 0x0003: Fuses high byte
	lpm	R24, Z+
	rcall	putbyte
	cpi	R30, 4
	brne	2b
	clr	R30

crcprompt:
	mov	R24, R11	; CRC (msb)
	rcall	putbytenocrc
	mov	R24, R10	; CRC (lsb)
	rcall	putbytenocrc
	rjmp	prompt

	
	;; 'A' : Set current address in R31:R30 (Z)
	;;
1:	cpi	R24, 'A'
	brne	1f
	rcall	getbyte
	mov	R31, R24	; R31 = MSB
	rcall	getbyte
	mov	R30, R24	; R30 = LSB
	rcall	chkcrc
	brne	error
	rjmp	prompt


	;; 'f': read flash page at R31:R30 (Z)
	;; 
1:	cpi	R24, 'f'
	brne	1f

	ldi	R20, PAGESIZE
2:	lpm	R24, Z+		; read flash byte
	rcall	putbyte		; send it
	dec	R20
	brne	2b		; until end of page
	rjmp	crcprompt


	;; 'e': Read EEPROM from R31:R30 (Z)
	;; 
1:	cpi	R24, 'e'
	brne	1f

	rcall	getbyte		; R24 = how many bytes to read
	mov	R20, R24
2:	rcall	eerd 		; Read EEPROM and add to CRC
	rcall	putbytenocrc
	dec	R20
	brne	2b		; Jusqu'au dernier
	rjmp	crcprompt


	;; 'E' : Write EEPROM at R31:R30 (Z)
	;; 
1:	cpi	R24, 'E'
	brne	1f

	rcall	getbyte		; R24 = how many bytes to program
	mov	R20, R24
	mov	R21, R24
	rcall	getbuf		; Load buffer
	brne	pdone		; Abort if error

	SPEED_0			; Factory clock speed
	movw	R28, R4		; Y = RAMSTART
2:	sbic	AP_EEPE		; Wait eeprom ready
	rjmp	2b
	ldi	R24, 0		; Command: erase & write
	XST	EECR, R24
	XST	EEARL, R30	; Address
	XST	EEARH, R31
	ld	R24, Y+		; Byte value
	XST	EEDR, R24
	sbi	AP_EEMPE	; Program
	sbi	AP_EEPE
	adiw	R30, 1		; Next address
	dec	R21		; Next byte
	brne	2b		; While some remain

	SPEED_1	R24		; High clock speed

	ldi	R24, CODE_ERS | CODE_WRT ; Code 'ERASED' + 'PROGRAMMED'

	;; End of programming
	;;   R24 holds the result code
	;;   Return to prompt
	;; 
pdone:	rcall	putbytenocrc
	rjmp	prompt


	;; Write FLASH memory
	;;
1:	cpi	R24, 'F'
	breq	pflash


	;; Resume application
	;;
1:	cpi	R24, 'X'
	brne	1f
	rcall	chkcrc
	breq	2f
	rjmp	error
2:	ldi	R24, '#'
	rcall	putbytenocrc

	.if	X_ONEWIRE == 0
	ldi	R24, 0		; Deinitialize ios
	XST	TXDDR, R24
	XST	TXDPORT, R24
	.endif

;; 	rjmp	APPSTART	; Erroneous address with ATtiny84, avr-as bug?
;;
;; 1e84:	79 cf       	rjmp	.-270    	; 0x1d78 <swuart_sync_10_1+0x22>

	rjmp	appstart	; use a trampoline


	;; Go re-compute application CRC
	;; and wait for '\n'
	;;
1:	rjmp	appcrc


	;; Program FLASH memory
	;;   Data bytes are first copied into RAM for timing reason
	;;
pflash:	ldi	R20, PAGESIZE
	rcall	getbuf		; Receive buffer + CRC
 	brne	pdone		; Bad buffer -> pdone

	;; Check programming address validity: page-aligned & before Diabolo
	;;
	ldi	R24, CODE_EAD	; Error code 'BAD ADDRESS'
	movw	R28, R30	; R29:R28 = Z
	subi	R28, lo8(start)
	sbci	R29, hi8(start)
	brcc	pdone
	andi	R28, PAGESIZE-1
	brne	pdone

#if defined HW_DEVICE_ATTINYX4
	;; 
	;; Place a jump to Diabolo in the reset vector for devices without
	;; a boot section
	;; 
	;;     RJMP opcode: 1100 kkkk kkkk kkkk = 0xC000 + K
	;;
	sbiw	R30, 0
	brne	2f
	ldi	R24, lo8(0xC000 + BOOTSTART/2-1)
	sts	RAMSTART+0, R24
	ldi	R24, hi8(0xC000 + BOOTSTART/2-1)
	sts	RAMSTART+1, R24
#endif

	;; Fill temporary page buffer
	;; 
2:	FLASH_CLRBUF		; Clear flash programming buffer

	ldi	R24, CODE_NONE	; Code 'NO ERROR'
	ldi	R18, 0xFF	; Received page virginity
	ldi	R19, 0xFF	; Current page virginity
	ldi	R20, 0xFF	; Pages equality

	movw	R28, R4		; Y = RAMSTART
	ldi	R22, PAGESIZE/2
2:	ld	R12, Y+		; Received byte
	lpm	R13, Z+		; Original byte

	and	R18, R12	; Update received page virginity
	and	R19, R13	; Update current page virginity
	cpse	R12, R13	; Update pages equality
	ldi	R20, 0		;

	mov	R0, R1		; Build a couple of bytes in R1:R0 for SPM
	mov	R1, R12		;
	sbrc	R30, 0		; One more byte if R30 is odd
	rjmp	2b		;

	sbiw	R30, 2		; 2 bytes back

	FLASH_LDBYTE		; Store R1:R0 in page programming buffer

	adiw	R30, 2		;

	dec	R22		; Repeat until end of page
	brne	2b		;

	cpi	R20, 0xFF	; Go to pdone if page is unchanged
	brne	4f		;
99:	rjmp	pdone		;

4:	subi	R30, lo8(PAGESIZE)	; Back to start of page's address
	sbci	R31, hi8(PAGESIZE)	;

	SPEED_0			; Revert to factory MCU clock speed

	;; Erase page if not virgin
	;;
	cpi	R19, 0xFF	;
	breq	4f		;
	ori	R24, CODE_EPRG | CODE_ERS ; Load error code: 'PROGRAMMING ERROR'+'ERASE'

	FLASH_PGERS		; Erase flash page

	;; Program page if received page is not virgin
	;;
4:	cpi	R18, 0xFF	;
	breq	4f		; 
	ori	R24, CODE_EPRG | CODE_WRT ; Load error code: 'PROGRAMMING ERROR'+'WRITE'

	FLASH_PGWRT		; Write page
	FLASH_ERWWS		; Enable RWW section

	;; Verify page content
	;;
4:	SPEED_1	R28		; Highest clock speed
	movw	R28, R4		; Y pointe le début de la page en RAM
	ldi	R22, PAGESIZE
2:	ld	R12, Y+		; Received byte
	lpm	R13, Z+		; Programmed byte
	cp	R12, R13
	brne	99b		; -> pdone
	dec	R22
	brne	2b		;
	andi	R24, ~CODE_EPRG	; Clear error code 'PROGRAMMING ERROR'
	rjmp	pdone

	;; Get R20 bytes stored in RAM, + CRC16
	;; Return with Z=1 if CRC is valid
	;;
getbuf:	movw	R28, R4		; RAMSTART
1:	rcall	getbyte
	st	Y+, R24
	dec	R20
	brne	1b

	;; Receive and check CRC
	;; Load '\x80' (CRC error) into R24
	;; Return with Z=1 if CRC is valid (== 0)
	;; 
chkcrc:	rcall	getbyte		; Receive CRC
	rcall	getbyte		;
	mov	R24, R10	; Check CRC
	or	R24, R11	; Z=1 if CRC is valid
	ldi	R24, CODE_ECRC	; 'CRC error' code, Z unmodified
	ret

	
	;; Read EEPROM : R24 = *(Z++)
	;; 
eerd:	sbic	AP_EEPE
	rjmp	eerd
	XST	EEARL, R30 
	XST	EEARH, R31
	sbi	AP_EERE
	XLD	R24, EEDR
	adiw	R30, 1
	rjmp	crcadd

	;; Delay R25:R24 + 6 cycles			(R24, R25)
	;; 3 + 4 (n/4-1) + 3 + 4 = 6 + n
	;; 
delay:				; [3] rcall
	sbiw	R24, 4		; [2]   |
	brcc	delay		; [2/1] |= 4
	ret			; [4]


	;; Receive one byte in R24			R22, R23, R24, R25
	;; 						R10, R11, R18, R19
	;;
getbyte:
	ldi 	R22, 9		; 8 data bits + 1 stop bit
1:	sbis	RXDPIN, BP_RXD	;	Wait RXD == 1
	rjmp	1b
1:	sbic 	RXDPIN, BP_RXD	; [1/2] Wait RXD == 0
	rjmp 	1b		; [2]

	movw	R24, R14	; [1]	|	Delay 1+1/2 bit (skip start)
	lsr	R25		; [1]	|
	ror	R24		; [1]	|
	add	R24, R14	; [1]	|
	adc	R25, R15	; [1]	|
	sbiw	R24, 7+6	; [2]	|=7
	rcall	delay

1:	XLD	R24, RXDPIN	; [1]	|	Sample one bit in T
	bst	R24, BP_RXD	; [1]	|
	dec 	R22		; [1]   |
	breq 	1f		; [1/2] |	IF last THEN break
	lsr 	R23		; [1]   |	Store T into byte buffer
	bld	R23, 7		; [1]	|
	movw	R24, R14	; [1]	|
	sbiw	R24, 9+4+6+2	; [2]	|=9	FIXME: +4 ?
	rcall	delay
	rjmp 	1b		; [2]   	Next bit
;; 1:	brtc	sync		; [1]		Stop bit == 0 -> resynchronise/restart
1:	mov	R24, R23	; [1]		Store received byte in R24

	;; Update CRC (R11:R10) with byte R24
	;; 						R10, R11, R18, R19
	;;
crcadd:				; [4] (call)
	mov	R19, R24	; [1] Copie

	mov	R18, R10	; [1] CRC = CRC>>8 | CRC<<8
	mov	R10, R11	; [1]
	mov	R11, R18	; [1]

	eor	R10, R19	; [1] CRC ^= byte

	mov	R18, R10	; [1] CRC = CRC ^ ((CRC & 0xFF) >> 4)
	swap	R18		; [1]
	andi	R18, 0x0F	; [1]
	eor	R10, R18	; [1]

	mov	R18, R10	; [1] CRC = CRC ^ ((CRC << 8) << 4)
	swap	R18		; [1]
	andi	R18, 0xF0	; [1]
	eor	R11, R18	; [1]

	mov	R18, R10	; [1] CRC = CRC ^ (((CRC & 0xFF) << 4) << 1)
	swap	R18		; [1]
	mov	R19, R18	; [1]
	andi	R18, 0xF0	; [1]
	andi	R19, 0x0F	; [1]
	lsl	R18		; [1]
	rol	R19		; [1]
	eor	R10, R18	; [1]
	eor	R11, R19	; [1]
	ret			; [4]=30


	;; Send one byte (R24, destroyed)
	;; Update CRC (initialized at 0xFFFF after prompt)
	;;
	;; 						R10, R11, R18, R19, R24, R25, R26, R27
	;;
putbyte:
	rcall	crcadd

	;;						R24, R25, R26, R27
	;; 
putbytenocrc:
	.if X_ONEWIRE
	sbi	TXDPORT, BP_TXD	; Setup TXD
	sbi	TXDDR, BP_TXD	;
	.endif
	ldi	R26, 10		; nbits = 1 start + 8 data + 1 stop
	mov	R27, R24
	com	R27		; Complement byte (optimization)
	sec			; Load start bit
1:	brcc	2f		; [1/2]	|	IF CARRY
	cbi	TXDPORT, BP_TXD	; [1]   |	THEN send '0'
	rjmp	3f		; [2]	|
2:	sbi	TXDPORT, BP_TXD	; [1]   |	ELSE send '1'
	nop			; [1]	|
3:	movw	R24, R14	; [1]	|
	sbiw	R24, 7+2+6+4	; [2]	|=7	FIXME: +2 ?
	rcall	delay
	lsr	R27		; [1]	|	Next bit
	dec	R26		; [1]	|
	brne	1b		; [2]	|=4	Repeat until last bit
	.if X_ONEWIRE
	cbi	TXDDR, BP_TXD	;
	cbi	TXDPORT, BP_TXD	; Release TXD
	.endif
	ret

	;; Execute SPM instruction after setting SPMCSR with R21 value
	;; 
#if defined HW_DEVICE_ATMEGAX8
dospm:  XST	SPMCSR, R21
	spm
1:	XSBIC	R21, SPMCSR, BP_SPMEN ; Wait end of SPM instruction
	rjmp	1b
	;; XLD	R21, 1<<BP_RWWSRE | 1<<BP_SPMEN ; Re-enable RWW section
	;; XST	SPMCSR, R21
	;; spm
;; 1:	XSBIC	R21, SPMCSR, BP_SPMEN ; Wait end of SPM instruction
;; 	rjmp	1b
	ret
#endif
