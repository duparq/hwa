
	;; -*- asm -*-

	;; Diabolo Is A BOotLOader
	;; 
	;; 1 or 2-wire serial link without timer nor interrupts
	;; initialized at Power-On Reset or Watchdog reset

	;; Operations:
	;;
	;;   Identify: 'i' -> data + CRC
	;;   Read one flash page: 'f' + addr -> data + CRC
	;;   Write one flash page: 'F' + addr + data + CRC -> Code
	;;   Read n eeprom bytes: 'e' + addr + n -> data + CRC
	;;   Write n eeprom bytes: 'E' + addr + n + bytes + CRC -> Code
	;;   Resume to application: 'X' + CRC -> Code
	;;   Unknown operation: -> '!' after CRC recomputation
	;;
	;;     Note: CRC is sent/received MSB first
	;;
	;; Returned codes
	;;
	CODE_CRC  = (1<<7)	; CRC error
	CODE_FAIL = (1<<4)	; Operation failed
	CODE_WRT  = (1<<1)	; Written
	CODE_ERS  = (1<<0)	; Erased
	CODE_OK = 0		; Operation succeeded

	;; RESET:	MCUSR != 0
	;; Application:	MCUSR == 0
	;; Loop:	

	
	;; TODO:
	;;   Use R22/R23 instead of R24/R25 for delay -> R24 holds the byte to tx/rx
	;; 
	;; Notes:
	;; 
	;; * could spare a few bytes by removing page programming verification
	;; (then diabolo.py would do it).


#if !defined HW_DEVICE_ATTINYX4 && !defined HW_DEVICE_ATMEGAX8
#  error Device is not supported
#endif

	;; Registers
	;;
	;; R1:R0      value written into flash page buffer
	;; R3:R2      CRC of application
	;; R5:R4      RAMSTART (used to store incomming data)
	;; R8         Status: 0: Diabolo just launched by RESET
	;;                    1: Diabolo just launched by application
	;;                    2: Communication established
	;; R9         OSCCAL value at reset
	;; R11:R10    CRC 16 bits (CCITT) of last transfered packet
	;; R15:R14    UART bit duration in cycles
	;; R16        general usage
	;; R17        FF if all application bytes are FF, general usage
	;; R18        CRC computation
	;; R19        CRC computation
	;; R20        counter for bytes to send/receive/read/program
	;; R21        general use
	;; R22        UART bits counter
	;; R23        UART received byte buffer
	;; R24        UART rx/tx byte
	;; R29:R28    Y: RAM address, Z backup
	;; R31:R30    Z: flash address counter (LPM/SPM)


	;; Macros for extended instructions
	;; 
	.include "atmelavr-xinstr.sx"


	;;  Registers
	;;
	SPL        = hw_addr(hw_reg(hw_core0, spl))
	SPH        = hw_addr(hw_reg(hw_core0, sph))
	MCUSR	   = hw_addr(hw_reg(hw_core0, mcusr))
	 BP_WDRF   = hw_bp(hw_reg(hw_core0, wdrf))
	 BP_PORF   = hw_bp(hw_reg(hw_core0, porf))

	SPMCSR	   = hw_addr(hw_reg(hw_flash0, csr))
	 BP_RWWSRE = hw_bp(hw_reg(hw_flash0, rwwsre))
	 BP_BLBSET = hw_bp(hw_reg(hw_flash0, blbset))
	 BP_PGWRT  = hw_bp(hw_reg(hw_flash0, pgwrt))
	 BP_PGERS  = hw_bp(hw_reg(hw_flash0, pgers))
	 BP_SPMEN  = hw_bp(hw_reg(hw_flash0, spmen))

	EEARL	   = hw_addr(hw_reg(hw_eeprom0, arl))
	EEARH	   = hw_addr(hw_reg(hw_eeprom0, arh))
	EEDR	   = hw_addr(hw_reg(hw_eeprom0, dr))
	EECR	   = hw_addr(hw_reg(hw_eeprom0, cr))
#define AP_EEMPE   hw_ap(hw_reg(hw_eeprom0, mpe))
#define AP_EEPE	   hw_ap(hw_reg(hw_eeprom0, pe))
#define AP_EERE	   hw_ap(hw_reg(hw_eeprom0, re))

	;; Communication pins: PIN_RXD and PIN_TXD can be the same
	;;
	RXDPORT	   = hw_addr(hw_reg(hw_sup(PIN_RXD), port))
	RXDPIN	   = hw_addr(hw_reg(hw_sup(PIN_RXD), pin))
	RXDDR	   = hw_addr(hw_reg(hw_sup(PIN_RXD), ddr))
	 BP_RXD	   = hw_bp(PIN_RXD)
	TXDPORT	   = hw_addr(hw_reg(hw_sup(PIN_TXD), port))
	TXDDR	   = hw_addr(hw_reg(hw_sup(PIN_TXD), ddr))
	 BP_TXD	   = hw_bp(PIN_TXD)

	;; Debug pin
	;;
#if defined PIN_DBG
	DBG = 1

	DBGPORT   = hw_addr(hw_reg(hw_sup(PIN_DBG), port))
	DBGPIN    = hw_addr(hw_reg(hw_sup(PIN_DBG), pin))
	DBGDDR    = hw_addr(hw_reg(hw_sup(PIN_DBG), ddr))
	DBGBIT    = hw_bp(PIN_DBG)

	.macro DBG_INIT
	sbi	DBGDDR, DBGBIT
	.endm
	.macro DBGT
	sbi	DBGPIN, DBGBIT
	.endm
	.macro DBG0
	cbi	DBGPORT, DBGBIT
	.endm
	.macro DBG1
	sbi	DBGPORT, DBGBIT
	.endm
#else
	.macro DBG_INIT
	.endm
	.macro DBGT
	.endm
	.macro DBG0
	.endm
	.macro DBG1
	.endm
#endif

	;; Constants
	;;
	PROTOCOL   = 4
	PAGESIZE   = HW_DEVICE_FLASH_PAGE_SIZE  ; from HWA
	FLASHSIZE  = HW_DEVICE_FLASH_SIZE       ;
	RAMSTART   = HW_DEVICE_RAM_START        ;
	RAMEND     = HW_DEVICE_RAM_START+HW_DEVICE_RAM_SIZE-1
	SIGNATURE0 = HW_A0(HW_DEVICE_SIGNATURE) ;
	SIGNATURE1 = HW_A1(HW_DEVICE_SIGNATURE) ;
	SIGNATURE2 = HW_A2(HW_DEVICE_SIGNATURE) ;

#if defined HW_DEVICE_ATTINYX4
	;; Allocate enough pages for Diabolo at end of flash memory
	;;
	NBLPAGES  = 10
#elif defined HW_DEVICE_ATMEGAX8
	;; Diabolo in boot section
	;;
	NBLPAGES  = HW_DEVICE_BOOTSECTION_SIZE / HW_DEVICE_FLASH_PAGE_SIZE
#endif
	APPSTART  = HW_DEVICE_APP_START
	BOOTSTART = FLASHSIZE - NBLPAGES*PAGESIZE

	;; Data in EEPROM
	;;
	;;   App CRC is stored MSB first in EEPROM because it must be
	;;   sent to the CRC algorithm in this order for checking
	;; 
	EEPCNT = HW_DEVICE_EEPROM_SIZE-4 ; 32 bit programmings count (MSB first)
	EECRC  = EEPCNT-4		 ; 16 bits application CRC (MSB first)

	;; Change MCU speed macros
	;;
#if defined XSPEED
	.macro SPEED1 reg
	ldi	\reg, 0xFF	; Highest clock speed
	XST	OSCCAL, \reg
	.endm
	.macro SPEED0
	XST	OSCCAL, R9	; Revert to factory MCU clock speed
	.endm
#else
	.macro SPEED1 reg
	.endm
	.macro SPEED0
	.endm
#endif


	;; Macros for flash memory programming
	;;   In devices without boot section
	;;
#if !defined HW_DEVICE_BOOTRST
	;;
	;; Devices without boot section: the MCU is halted when the
	;; flash memory is busy
	;;
	.macro	FLASH_CLRBF
	ldi	R21, 1<<BP_RWWSRE | 1<<BP_SPMEN
	XST	SPMCSR, R21
	spm
	.endm

	.macro	FLASH_LDBYTE
	ldi	R21, 1<<BP_SPMEN
	XST	SPMCSR, R21
	spm
	.endm

	.macro	FLASH_PGERS
	ldi	R21, 1<<BP_PGERS | 1<<BP_SPMEN
	XST	SPMCSR, R21
	spm
	.endm

	.macro	FLASH_PGWRT
	ldi	R21, 1<<BP_PGWRT | 1<<BP_SPMEN
	XST	SPMCSR, R21
	spm
	.endm

#  define FLASH_ERWWS
#else
#  define FLASH_CLRBF
	.macro	FLASH_LDBYTE
	ldi	R21, 1<<BP_SPMEN
	rcall	dospm
	.endm

	.macro	FLASH_PGERS
	ldi	R21, 1<<BP_PGERS | 1<<BP_SPMEN
	rcall	dospm
	.endm

	.macro	FLASH_PGWRT
	ldi	R21, 1<<BP_PGWRT | 1<<BP_SPMEN
	rcall	dospm
	.endm

	.macro	FLASH_ERWWS
	ldi	R21, 1<<BP_RWWSRE | 1<<BP_SPMEN ; Re-enable RWW section
	rcall	dospm
	.endm
#endif


	;; /********************************/
	;; /*            START             */
	;; /*                              */
	;; /*     Diabolo entry point      */
	;; /*                              */
	;; /********************************/

	;; Put this code in section .init1 so that it will not be removed
	;; by the optimizer!
	;;
	.section .init1

#if !defined HW_DEVICE_BOOTRST
	;; 
	;; Device without boot section: place a jump to Diabolo in RESET vector
	;;
	rjmp	reset
#endif

	.org BOOTSTART, 0xFF	; Fill unused space with 0xFF

	;; This point is reached only after a RESET
	;;   If the application wants to start Diabolo, it must jump to the
	;;   entry point at the end of flash memory
	;;
	;; Start immediately the application if the reset is caused by the
	;; watchdog (Note: the brownout flag is always set at power-on).
	;;
reset:	XLD	R24, MCUSR
	sbrc	R24, BP_WDRF
#if defined XSPEED
app:	rjmp	APPSTART
#else
sapp:	rjmp	FLASHSIZE+APPSTART
#endif

	;; Store status in R8:
	;;   0: Diabolo just launched by RESET
	;;
	clr	R8

	;; This point is reached:
	;;   after a RESET (R8==0)
	;;   or from the entry point for the application (R8==1)
	;;   or after an unknown command (R8==2)
	;;
	;; SP points to RAMEND after RESET then no initialization is required
	;; The application has to initialize SP before launching Diabolo
	;;
	;; ldi	R24, lo8(RAMEND)
	;; out	SPL, R24
	;; ldi	R24, hi8(RAMEND)
	;; out	SPH, R24
init:	DBG_INIT
	DBG1
#if defined XSPEED
	XLD	R9, OSCCAL	; Store factory clock speed
	SPEED1	R23		; Highest clock speed
#endif

	;; Compute the CRC of application code ignoring the trailing
	;; 0xFF bytes: read from the end to the beginning.
	;; Also check the RXD pin level.
	;;
	;; Cycles = 48*nbytes
	;;        = 48 ms/kB of flash code @1MHz
	;;
	ldi	R16, 0xFF	;	R16==0xFF while RXD==0
	ldi	R17, 0xFF	;	R17==0xFF while bytes read are 0xFF
	movw	R10, R16	;	Init CRC to 0xFFFF
	ldi	R30, lo8(FLASHSIZE-NBLPAGES*PAGESIZE-1) ; Begin with last byte
	ldi	R31, hi8(FLASHSIZE-NBLPAGES*PAGESIZE-1) ; of application code
2:	lpm	R24, Z		; [3]
	and	R17, R24	; [1]
	cpi	R17, 0xFF	; [1]	Do not compute 0xFF bytes at end of app section
	breq	3f		; [1]
	clr	R17		; [1]
	rcall	crcadd		; [30]
3:	sbic	RXDPIN, BP_RXD	; [2]	Clear R16 if RXD == 1
	clr	R16		; [1]

	DBGT

	sbiw	R30, 1		; [2]

#if !defined HW_DEVICE_BOOTRST
	cpi	R31, 0		; [1]	Do not compute the RESET vector for devices
	brne	2b		; [2]   without a boot section
	cpi	R30, 2		; [1]
	brcc	2b		; [2]=48
#else
	brcc	2b		; [2]=44
#endif

	;; Copy application CRC in R3:R2 (used for 'i')
	;; Check against value stored in EEPROM
	;; 
	movw	R2, R10
	ldi	R30, lo8(EECRC)	; Z = address of CRC stored in EEPROM
	ldi	R31, hi8(EECRC)
	rcall	eerd		; Read one byte of EEPROM and update CRC
	rcall	eerd		; Read one byte of EEPROM and update CRC

	;; If R8==2 (communication already started) go into error state
	;;
	sbrc	R8, 1
	rjmp	error

	;; If R8==1 (Diabolo just started by application) go synchronizing
	;;
	sbrc	R8, 0
	rjmp	1f

	;; R8==0, Diabolo just started from RESET
	;; Start the application if:
	;;   RXD did not remain 0 while computing CRC (R16==0)
	;;   and CRC of application is OK (R10 == R11 == 0)
	;;   and all bytes read were not 0xFF (R17==0)
	;;     (useless if reset vector is computed in crc)
	;;
	or	R16, R10
	or	R16, R11
	or	R16, R17
#if defined XSPEED
	brne	2f
sapp:	SPEED0
	rjmp	app
2:
#else
	breq	sapp
#endif

1:	DBG1

	;; Store RAMSTART into R5:R4
	;; 
	ldi	R16, lo8(RAMSTART)
	ldi	R17, hi8(RAMSTART)
	movw	R4, R16		; R4 = RAMSTART

	;; This is the first time we are here:
	;;   synchronize the software UART
	;;     compute bit duration in SYSHZ cycles units
	;;     store it in R15:R14
	;;
sync:	DBG0

#include "diabolo-atmelavr-sync-10-1.sx"
	movw	R14, R24

	;; Wait end of byte and 1 more byte
	;;   If RXD goes low, re-sync
	;;
	ldi	R20, 20		; 20 bits
2:	movw	R24, R14	;
	rcall	delay		;
	dec	R20		;
	sbic	RXDPIN, BP_RXD	; if RXD is low
	brne	2b		;
	brne	sync		;   -> sync again

	DBG1

	;; Initialize TXD pin if separate from RXD
	;;
#if hw_id(PIN_RXD) != hw_id(PIN_TXD)
	sbi	TXDPORT, BP_TXD
	sbi	TXDDR, BP_TXD
#endif
	inc	R8		; Initializations done, communication can begin

	;; Error state: send '!' and wait for '\n' before giving prompt
	;;
error:	ldi	R24, '!'
	rcall	putbyte
	rcall	getbyte
	cpi	R24, '\n'
	brne	error

	;; Main loop:
	;;   send prompt '#'
	;;   wait for a character command
	;;   process command
	;;
prompt:	ldi	R24, '#'	; 0x23
	rcall	putbyte
	ldi	R24, 0xFF
	mov	R10, R24	; Initialize communication CRC to 0xFFFF
	mov	R11, R24
	rcall	getbyte		; Get command byte

	;; 'i': identify
	;; 
xi:	cpi	R24, 'i'
	brne	1f
	ldi	R24, PROTOCOL	; 0: Diabolo protocol
	rcall	putbytecrc
	ldi	R24, SIGNATURE0	; 1-3: device signature
	rcall	putbytecrc
	ldi	R24, SIGNATURE1
	rcall	putbytecrc
	ldi	R24, SIGNATURE2
	rcall	putbytecrc
	ldi	R24, NBLPAGES	; 4: number of pages for bootloader
	rcall	putbytecrc
	mov	R24, R3		; 5: application CRC (MSB)
	rcall	putbytecrc
	mov	R24, R2		; 6: application CRC (LSB)
	rcall	putbytecrc
	clr	R31				;  7: Fuses low byte      (0x0000)
	clr	R30				;  8: Lock bits		  (0x0001)
2:	ldi	R24, 1<<BP_BLBSET | 1<<BP_SPMEN	;  9: Fuses extended byte (0x0002)
	XST	SPMCSR, R24			; 10: Fuses high byte	  (0x0003)
	lpm	R24, Z+
	rcall	putbytecrc
	cpi	R30, 4
	brne	2b

	;; Send CRC before resuming to prompt '#'
crcprompt:
	mov	R24, R11	; CRC (msb)
	rcall	putbyte
	mov	R24, R10	; CRC (lsb)
	rcall	putbyte
	rjmp	prompt


	;; Read flash page: 'f' + addr
	;; 
1:
xf:	cpi	R24, 'f'
	brne	1f
	rcall	getaddr		; Get address in Z
	ldi	R20, PAGESIZE
2:	lpm	R24, Z+		; Read flash byte
	rcall	putbytecrc	; Send it
	dec	R20
	brne	2b		; Until end of page
	rjmp	crcprompt	; Send CRC and resume to prompt


	;; Receive an address (Z)
	;; 
getaddr:
	rcall	getbyte
	mov	R30, R24	; LSB
	rcall	getbyte
	mov	R31, R24	; MSB
	ret


	;; Get R20 bytes stored in RAM, + CRC16
	;; Return with Z=1 if CRC is valid
	;;
getbuf:	movw	R28, R4		; RAMSTART
2:	rcall	getbyte
	st	Y+, R24
	dec	R20
	brne	2b

	;; Receive and check CRC
	;; Load '\x80' (CRC error) into R24
	;; Return with Z=1 if CRC is valid (== 0)
	;; 
getcrc:	rcall	getbyte		; Receive CRC (MSB first)
	rcall	getbyte		;
	mov	R24, R10	; Check CRC
	or	R24, R11	; Z=1 if CRC is valid
	ldi	R24, CODE_CRC	; Z unmodified
	ret


	;;   Write flash page: 'F' + addr + data + CRC
	;;
1:
xF:	cpi	R24, 'F'
	brne	1f
	rcall	getaddr		; Get address and store it in Z
	ldi	R20, PAGESIZE
	rcall	getbuf		; Get R20 bytes + CRC and store them in RAM
	brne	abort		; Abort if CRC error
	ldi	R24, CODE_FAIL | CODE_ERS	; Return code in R24
	;;
	;; Erase page at address Z
	;;
	FLASH_PGERS		; Erase page
	FLASH_ERWWS		; Re-enable RWW section if device has a bootsection
	;;
	;; Copy data bytes from RAM to flash page buffer
	;; 
	;; The page buffer is cleared after power-on reset and by the following
	;; PGWRT or ERWWS operations but for devices without boot section, no
	;; ERWWS operation is performed and PGWRT is not performed on virgin pages.
	;;
	FLASH_CLRBF
	movw	R28, R4		; Y = RAMSTART (where the data bytes are stored)
	ldi	R20, PAGESIZE/2
	ldi	R23, 0xFF
2:	ld	R0, Y+
	ld	R1, Y+
	and	R23, R0
	and	R23, R1
	FLASH_LDBYTE		; Load byte to be programmed at address Z
	adiw	R30, 2
	dec	R20
	brne	2b
	;;
	;; Program the page
	;;
	cpi	R23, 0xFF
	breq	2f		   ; No need to program a virgin page
	ori	R24, CODE_WRT
	subi	R30, lo8(PAGESIZE) ; Reset Z to the address of the page to write
	sbci	R31, hi8(PAGESIZE)
	FLASH_PGWRT		; Write page
	FLASH_ERWWS		; Re-enable RWW section if device has a bootsection
	;;
	;; Verify written data
	;;
2:	movw	R28, R4		; Y = RAMSTART (where the data bytes are stored)
	ldi	R20, PAGESIZE
2:	ld	R0, Y+
	lpm	R1, Z+
	cpse	R0, R1
	rjmp	abort
	dec	R20
	brne	2b
	andi	R24, ~CODE_FAIL	; Error code in R24
abort:	rcall	putbyte
	rjmp	prompt


	;; Read n eeprom bytes: 'e' + addr + n
	;; 
1:
xe:	cpi	R24, 'e'
	brne	1f
	rcall	getaddr		; Get address and store it in Z
	rcall	getbyte		; R24 = how many bytes to read
	mov	R20, R24
2:	rcall	eerd 		; Read EEPROM and add to CRC
	rcall	putbytecrc
	dec	R20
	brne	2b		; Until the last one
	rjmp	crcprompt


	;;   Write n eeprom bytes: 'E' + addr + n + bytes + CRC ; Code
	;; 
1:
xE:	cpi	R24, 'E'
	brne	1f
	rcall	getaddr		; Get address and store it in Z
	rcall	getbyte		; R24 = how many bytes to program
	mov	R20, R24
	mov	R21, R24
	rcall	getbuf		; Load buffer
	brne	abort		; Abort if error
	;;
	;; Program the data
	;;
	SPEED0			; Factory clock speed

	movw	R28, R4		; Y = RAMSTART
2:	ldi	R24, 0		; Command: erase & write
	XST	EECR, R24
	XST	EEARL, R30	; Address
	XST	EEARH, R31
	ld	R24, Y+		; Byte value
	XST	EEDR, R24
	sbi	AP_EEMPE	; Program
	sbi	AP_EEPE
3:	sbic	AP_EEPE		; Wait eeprom ready
	rjmp	3b
	adiw	R30, 1		; Next address
	dec	R21		; Next byte
	brne	2b		; While some remain

	SPEED1	R24		; High clock speed
	;;
	;; No verification
	;;
	rjmp	prompt


	;; Resume to application
	;;
1:
xX:	cpi	R24, 'X'
	brne	1f
	rcall	getcrc
	breq	2f
	rjmp	error
2:	ldi	R24, CODE_OK
	rcall	putbyte
	;;
	;; Deinitialize TXD pin if not the same as RXD
	;; 
#if hw_id(PIN_RXD) != hw_id(PIN_TXD)
	ldi	R24, 0
	XST	TXDDR, R24
	XST	TXDPORT, R24
#endif
	;; Jump to application
	;;
	rjmp	sapp


	;; Unknown command then go re-compute application CRC
	;; and enter error state
	;;
1:
x:	rjmp	init

	
	;; Read EEPROM : R24 = *(Z++)
	;; 
eerd:	XST	EEARL, R30
	XST	EEARH, R31
	sbi	AP_EERE
	XLD	R24, EEDR
	adiw	R30, 1
	ret

	;; Delay R25:R24 + 6 cycles			(R24, R25)
	;; 3 + 4 (n/4-1) + 3 + 4 = 6 + n
	;; 
delay:				; [3] rcall
	sbiw	R24, 4		; [2]   |
	brcc	delay		; [2/1] |= 4
	ret			; [4]


	;; Receive one byte in R24			R22, R23, R24, R25
	;; 						R10, R11, R18, R19
	;;
getbyte:
	ldi 	R22, 9		; 8 data bits + 1 stop bit
2:	sbis	RXDPIN, BP_RXD	;	Wait RXD == 1
	rjmp	2b
2:	sbic 	RXDPIN, BP_RXD	; [1/2] Wait RXD == 0
	rjmp 	2b		; [2]

	movw	R24, R14	; [1]	|	Delay 1+1/2 bit (skip start)
	lsr	R25		; [1]	|
	ror	R24		; [1]	|
	add	R24, R14	; [1]	|
	adc	R25, R15	; [1]	|
	sbiw	R24, 7+6	; [2]	|=7
	rcall	delay

2:	XLD	R24, RXDPIN	; [1]	|	Sample one bit in T
	bst	R24, BP_RXD	; [1]	|
	dec 	R22		; [1]   |
	breq 	1f		; [1/2] |	IF last THEN break
	lsr 	R23		; [1]   |	Store T into byte buffer
	bld	R23, 7		; [1]	|
	movw	R24, R14	; [1]	|
	sbiw	R24, 9+4+6+2	; [2]	|=9	FIXME: +4 ?
	rcall	delay
	rjmp 	2b		; [2]   	Next bit
;; 2:	brtc	sync		; [1]		Stop bit == 0 -> resynchronise/restart
1:	mov	R24, R23	; [1]		Store received byte in R24

	;; Update CRC (R11:R10) with byte R24
	;; 						R10, R11, R18, R19
	;;
crcadd:				; [4] (call)
	mov	R19, R24	; [1] Save byte

	mov	R18, R10	; [1] CRC = CRC>>8 | CRC<<8
	mov	R10, R11	; [1]
	mov	R11, R18	; [1]

	eor	R10, R19	; [1] CRC ^= byte

	mov	R18, R10	; [1] CRC = CRC ^ ((CRC & 0xFF) >> 4)
	swap	R18		; [1]
	andi	R18, 0x0F	; [1]
	eor	R10, R18	; [1]

	mov	R18, R10	; [1] CRC = CRC ^ ((CRC << 8) << 4)
	swap	R18		; [1]
	andi	R18, 0xF0	; [1]
	eor	R11, R18	; [1]

	mov	R18, R10	; [1] CRC = CRC ^ (((CRC & 0xFF) << 4) << 1)
	swap	R18		; [1]
	mov	R19, R18	; [1]
	andi	R18, 0xF0	; [1]
	andi	R19, 0x0F	; [1]
	lsl	R18		; [1]
	rol	R19		; [1]
	eor	R10, R18	; [1]
	eor	R11, R19	; [1]
	ret			; [4]=30


	;; Send one byte (R24, destroyed)
	;; Update CRC (initialized at 0xFFFF after prompt)
	;;
	;; 						R10, R11, R18, R19, R24, R25, R26, R27
	;;
putbytecrc:
	rcall	crcadd

	;;						R24, R25, R26, R27
	;; 
putbyte:
#if hw_id(PIN_RXD) == hw_id(PIN_TXD)
	sbi	TXDPORT, BP_TXD	; Set RXD/TXD as output high
	sbi	TXDDR, BP_TXD	;
#endif
	ldi	R26, 10		; nbits = 1 start + 8 data + 1 stop
	mov	R27, R24
	com	R27		; Complement byte (optimization)
	sec			; Load start bit
2:	brcc	3f		; [1/2]	|	IF CARRY
	cbi	TXDPORT, BP_TXD	; [1]   |	THEN send '0'
	rjmp	4f		; [2]	|
3:	sbi	TXDPORT, BP_TXD	; [1]   |	ELSE send '1'
	nop			; [1]	|
4:	movw	R24, R14	; [1]	|
	sbiw	R24, 7+2+6+4	; [2]	|=7	FIXME: +2 ?
	rcall	delay
	lsr	R27		; [1]	|	Next bit
	dec	R26		; [1]	|
	brne	2b		; [2]	|=4	Repeat until last bit
#if hw_id(PIN_RXD) == hw_id(PIN_TXD)
	cbi	TXDDR, BP_TXD	;
	cbi	TXDPORT, BP_TXD	; Release TXD
#endif
	ret

	;; Execute SPM instruction after setting SPMCSR with R21 value
	;; 
#if defined HW_DEVICE_BOOTRST
dospm:  XST	SPMCSR, R21
	spm
2:	XSBIC	R21, SPMCSR, BP_SPMEN ; Wait end of SPM instruction
	rjmp	2b
	;; XLD	R21, 1<<BP_RWWSRE | 1<<BP_SPMEN ; Re-enable RWW section
	;; XST	SPMCSR, R21
	;; spm
;; 1:	XSBIC	R21, SPMCSR, BP_SPMEN ; Wait end of SPM instruction
;; 	rjmp	1b
	ret
#endif

	;; Entry point from the application
	;;   The application must initialize SP=RAMEND and R8=1
	;; 
	.org	FLASHSIZE-2, 0xFF
	rjmp	init
