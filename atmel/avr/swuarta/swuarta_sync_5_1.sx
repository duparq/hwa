
	;; -*- asm -*-

	;; Auto-synchronization for software UART
	;;
	;; This code is designed to be executed from the START ISR but must be
	;; included after the cycles computations are done.
	;;
	;; Baudrate is determined by measuring the low-level durations of a
	;; 5 bits low / 1 bit low sequence (e.g. the ASCII 'A' character).
	;;
	;; Consecutive low-level durations t1 and t2 are measured.
	;; When 4.75×t2 <= t1 <= 5.25×t2, synchronization is done
	;; and r25:r24 contains the bit duration (baudrate) in CPU cycles.

#if !CHECK_START_EDGE
#  error Autosync needs to detect both falling and rising edges
#endif

	;; Start date is stored in r25:r24
	;; r26 and SREG are pushed
	;;
	.section	.text.HW_G3(,hw_swuart,sync),"ax",@progbits
HW_G3(,hw_swuart,sync):
	sbic	RXDPIN, RXDBIT
	rjmp	2f

	;; Falling edge
	;;
	;; 	Memorize the date in comp
	;;
	XST	comp+0, r24
#	if COUNT_BN == 16
	XST	comp+1, r25
#	endif
	;;
	;; 	Shift: dt0 <- dtn
	;;
	lds	r26, dtn+0
	sts	dt0+0, r26
#	if COUNT_BN == 16
	lds	r26, dtn+1
	sts	dt0+1, r26
#	endif
	rjmp	HW_G3(,hw_swuart,st99) /* done */


	;; Rising edge
	;;
	;; 	Memorise in dtn (r25:r24) the duration of the low-level
	;;
2:
	push	r28
#	if COUNT_BN == 16
	;; push	r25
	push	r27
	push	r29
#	endif

	XLD	r26, comp+0
	sub	r24, r26
	sts	dtn+0, r24
#	if COUNT_BN == 16
	XLD	r27, comp+1
	sbc	r25, r27
	sts	dtn+1, r25
#	endif
	;;
	;;	Compute r27:r26 = 5×t2
	;;
#	if COUNT_BN == 8
	mov	r26, r24	; r26 = t2
	lsl	r26		;
	lsl	r26		;
	add	r26, r24	; r26 = 5×t2
#	endif
#	if COUNT_BN == 16
	movw	r26, r24	; r27:r26 = t2
	lsl	r26		;
	rol	r27		; r27:r26 = 2×t2
	lsl	r26		;
	rol	r27		; r27:r26 = 4×t2
	add	r26, r24	;
	adc	r27, r25	; r27:r26 = 5×t2
#	endif
	;;
	;;	Compute r29:r28 = dt = (t2+2)/4
	;; 
#	if COUNT_BN == 8
	mov	r28, r24	; r28 = t2
	subi	r28, -2		; r28 = t2+2
	lsr	r28		;
	lsr	r28		; r28 = (t2+2)/4
#	endif
#	if COUNT_BN == 16
	movw	r28, r24	; r29:r28 = t2
	adiw	r28, 2		; r29:r28 = t2+2
	lsr	r29		;
	ror	r28		; r29:r28 = (t2+2)/2
	lsr	r29		;
	ror	r28		; r29:r28 = (t2+2)/4
#	endif
	;; 
	;;	Compute r27:r26 = 5×t2 - dt
	;; 
	sub	r26, r28	;
#	if COUNT_BN == 16
	sbc	r27, r29	; r27:r26 = 5×t2 - dt
#	endif
	;;
	;;	 Check the lower bound
	;;
	lds	r24, dt0+0
	cp	r24, r26	; if ( t1 < 5×t2 - dt )
#	if COUNT_BN == 16
	lds	r25, dt0+1
	cpc	r25, r27
#	endif
	brcs	3f		; then t1 is too low, get another sample
	;;
	;;	Compute r27:r26 = 5×t2 + dt
	;; 
	add	r26, r28	; r26 = 5×t2
#	if COUNT_BN == 16
	adc	r27, r29	; r27:r26 = 5×t2
#	endif
	add	r26, r28	; r26 = 5×t2 + dt
#	if COUNT_BN == 16
	adc	r27, r29	; r27:r26 = 5×t2 + dt
#	endif
	;;
	;;	Check the upper bound
	;; 
	cp	r24, r26	; if ( t1 > 5×t2 + dt )
#	if COUNT_BN == 16
	cpc	r25, r27
#	endif
	brcc	3f		; then t1 is too high, get another sample
	;;
	;;	5 / 1 sequence is validated
	;;	Compute dt0 = dtn + (dtn+1)/2 - delay
	;;
	;;	Add 16 cycles (better sooner than later!)
	;;
	DELAY=(CY_STSEI+CY_RXSEI+16)/HW_G2(hw_swuart,clk_div)

#	if COUNT_BN == 8
	lds	r24, dtn+0
	mov	r26, r24	; r24 = dtn in counter units
	inc	r26		; r26 = (dtn+1)/2
	lsr	r26		;
#	endif
#	if COUNT_BN == 16
	lds	r24, dtn+0
	lds	r25, dtn+1
	movw	r26, r24	; r25:r24 = dtn in counter units
	adiw	r26, 1		; r27:r26 = (dtn+1)/2
	lsr	r27		;
	ror	r26		;
#	endif

	add	r24, r26	; r25:r24 = dtn + (dtn+1)/2
#	if COUNT_BN == 16
	adc	r25, r27	;
#	endif

	subi	r24, lo8(DELAY)
#	if COUNT_BN == 16
	sbci	r25, hi8(DELAY)
#	endif
	;; 
	;;	Store dt0
	;; 
	sts	dt0+0, r24
#	if COUNT_BN == 16
	sts	dt0+1, r25
#	endif
	;;
	;;	Date of the next bit (stop)
	;;
	XLD	r24, comp+0
	lds	r25, dtn+0
	add	r24, r25
	XST	comp+0, r24

#	if COUNT_BN == 16
	XLD	r24, comp+1
	lds	r25, dtn+1
	adc	r24, r25
	XST	comp+1, r24
#	endif

	;; Set 'bit' reception routine up
	;;
	ldi	r24, 0		; 0 data bit to receive (stop bit)
	sts	nbit, r24	;

	enable_match(R24)

	;;
	;;	Assert 'synced'
	;; 
	;; XSB	r24, F_SYNCED
3:	
#	if COUNT_BN == 16
	pop	r29
	pop	r27
	;; pop	r25
#	endif
	pop	r28

	rjmp	HW_G3(,hw_swuart,st99)
