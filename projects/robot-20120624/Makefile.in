
#	Output basename
#
OUT		=	out

#	Build directory
#
BUILDIR		=	build


ARCH		= avr-
MMCU		= -mmcu=$(MCU)
#MMCU		= -mmcu=avr5
AFLAGS		= $(MMCU)
CFLAGS		= $(MMCU)
#CFLAGS		+= -mcall-prologues
LDFLAGS		= $(MMCU)

#LD_LIBRARY_PATH := /home/indy/dev/avr/toolchain/120404/install/avr/lib
PATH		:= /home/indy/dev/avr/toolchain/120404/install/bin:$(PATH)

#	Commandes et options de compilation
#
CC		= $(ARCH)gcc
AS		= $(ARCH)as
OBJCOPY		= $(ARCH)objcopy
ODUMP		= $(ARCH)objdump
GDB		= $(ARCH)gdb
SIZE		= $(ARCH)size
STD		= c99


CFLAGS		+= -std=$(STD)
CFLAGS		+= -Wall
CFLAGS		+= -Wextra
CFLAGS		+= -pedantic
CFLAGS		+= -fomit-frame-pointer
CFLAGS		+= -ffunction-sections
#CFLAGS		+= -fno-builtins
CFLAGS		+= -fpack-struct
#CFLAGS		+= -fshort-enums
#CFLAGS		+= -g
#CFLAGS		+= -pipe
CFLAGS		+= -Os
#CFLAGS		+= -O0
#CFLAGS		+= -O1
#CFLAGS		+= -O2
#CFLAGS		+= -O3


DEFINES		+= -DHW_DEVICE=$(MCU)
DEFINES		+= -DFUSE_LB=$(FUSE_LB)
DEFINES		+= -DFUSE_HB=$(FUSE_HB)
DEFINES		+= -DFUSE_EB=$(FUSE_EB)

CFLAGS		+= $(DEFINES)
CFLAGS		+= $(INCLUDES)

AFLAGS		+= $(INCLUDES)

#LDFLAGS		+= -s
LDFLAGS		+= -Wl,-Map,$(BUILDIR)/$(OUT).map,--cref
#LDFLAGS		+= -Wl,-u,vfprintf -lprintf_min
#LDFLAGS		+= -Wl,--section-start=.bootloader=$(BOOTLOADER)
#LDFLAGS		+= -Wl,--defsym=diabolo=$(BOOTLOADER)
#LDFLAGS		+= -Wl,--defsym=program_start=0
#LDFLAGS		+= -nostartfiles
LDFLAGS		+= -Wl,--gc-sections
#LDFLAGS		+= -nostdlib # Provide clear_bss aso
#LDFLAGS		+= -Wl,--section-start=.protext=0x1E00
#LDFLAGS		+= -Wl,--section-start=.bss.pro=0x800100
#LDFLAGS		+= -L/usr/lib/avr/lib
#LDFLAGS	+= -L/home/indy/dev/avr/toolchain/current/install/avr/lib
#LDFLAGS		+= -lm

ODUMPFLAGS	= -S
#ODUMPFLAGS	= -D

DEPS		= $(BUILDIR)/$(OUT).$(MCU).deps


#	Determine object file names from their extension
#
S1		=	$(SOURCES:.c=.$(MCU).o)
S2		=	$(S1:.s=.$(MCU).o)
S3		=	$(S2:.sx=.$(MCU).o)
OBJECTS		=	$(patsubst %,$(BUILDIR)/%,$(S3))



all:	deps hex bin lst size

hex:	$(BUILDIR)/$(OUT).hex
bin:	$(BUILDIR)/$(OUT).bin
lst:	$(BUILDIR)/$(OUT).lst

size:	$(BUILDIR)/$(OUT).elf
	$(SIZE) $^


#	Compiling rules
#
%.bin : %.elf
	$(OBJCOPY) -R .eeprom -O binary --gap-fill=0xFF --pad-to $(ROMEND) $^ $@

%.hex : %.elf
	$(OBJCOPY) --gap-fill=0xFF -R .eeprom -O ihex $^ $@

%.lst : %.elf
	$(ODUMP) $(ODUMPFLAGS) $^ >$@

%.elf:	%.o
	$(CC) $(LDFLAGS) -o $@ $^

#%.cp.c: %.c
#	$(CPP) $(CFLAGS) $< |sed -e 's/;/;\n/g'|bcpp -s -i 2 -bcl | sed -e 's/#/\/\//g' > $@

%.cp.c: %.c
	$(CPP) $(CFLAGS) $< >$@

$(BUILDIR)/$(OUT).elf : $(OBJECTS)
	$(CC) $(LDFLAGS) -o $@ $^ $(LIBS)

$(BUILDIR)/%.$(MCU).o : %.c
	@mkdir -p $(dir $@)
	$(CC) $(CFLAGS) -c $< -o $@

$(BUILDIR)/%.$(MCU).o : %.s
	@mkdir -p $(dir $@)
	$(AS) $(AFLAGS) $< -o $@

$(BUILDIR)/%.$(MCU).o : %.sx
	@mkdir -p $(dir $@)
	$(CC) $(CFLAGS) -c $< -o $@

_$(BUILDIR)/%.$(MCU).o : %.sx
	@mkdir -p $(dir $@)
	$(CC) -x assembler-with-cpp $(CFLAGS) -c $< -o $@

_$(BUILDIR)/%.$(MCU).o : %.s
	@mkdir -p $(dir $@)
	$(CC) $(CFLAGS) -c $< -o $@

%.s : %.c
	$(CC) $(MMCU) -std=c99 -Wall -Wextra -Os -c -g -S $< -o $@


#	Nettoye le répertoire
#
clean:
	find . '(' 			\
		-name '*~' 		\
		-o -name '*.deps' 	\
		-o -name '*.map' 	\
		-o -name '*.a'		\
		-o -name '*.bin'	\
		-o -name '*.cpp.*'	\
		-o -name '*.cp.*'	\
		-o -name '*.o'		\
		-o -name '*.pyc'	\
		-o -name '*.so'		\
		-o -name '*.out'	\
		-o -name '*.elf'	\
		-o -name '*.hex'	\
		')' -exec rm {} ';'
	rm -rf $(BUILDIR)

#	Calcule les dépendances des fichiers sources (.c)
#
deps:	$(DEPS)

$(DEPS): $(SOURCES)
	@echo Rebuilding deps...
	@mkdir -p $(dir $@)
	@>$@
	@for s in $(SOURCES) ; do \
	  $(CC) -MM $(DEFINES) $(MMCU) \
	    -MT $(BUILDIR)/$(notdir $${s%.*}.$(MCU).o) $(INCLUDES) $$s >>$@ ;\
	done


tarball: clean
	SRC=$$(basename $$PWD)					;\
	DST=$$SRC.tar.bz2					;\
	tar -cvO --exclude=trash --exclude=$$DST		\
		../$$SRC | bzip2 >$$DST


#	Liste des cibles qui ne sont pas des fichiers
#
.PHONY: deps flash load upload download erase read_fuses select_xtal_osc \
	select_intern_osc_1 select_intern_osc_8 reset clean deps size


#	Inclut les dépendances (si elles existent déjà).
#
-include $(DEPS)
