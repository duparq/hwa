
	;; Synchronize UART :
	;;   Measure consecutive low-level durations: t0 and t.
	;;   When 8×(t0-t0/16) <= t <= 8×(t0+t0/16), synchronization is done
	;;   and R15:R14 contains the bit duration (baudrate) in CPU cycles.
	;;
	;; Durations are measured in units of 5 cycles.
	;; 
	;; Counts overflow at 65535 units, i.e. 65535*5 cycles
	;; That means that the longest low-level duration must be < 327675 cycles
	;; and this routine can not synchronize at speeds below SYSHZ/(327675/8) bps
	;; using 8 low-level bits characters, i.e. 195 bps @8 MHz.
	;; 
	;;   8 MHz / 1200 bps
	;;    1 bit = 833.3µs = 6666.7 cycles = 1333.3 units
	;;    8 bits = 10666.7 unités
	;;    t1 = 1331, t8 = 10653		dt = 6658
	;;
	;;   8 MHz / 9600 bps
	;;    1 bit = 104.2µs = 833 cycles = 166.6 units
	;;    8 bits = 1333.3 unités
	;;    t1 = 166, t8 = 1331		dt = 832
	;;
	;;   8 MHz / 115200 bps
	;;    1 bit = 8.68µs = 69.4 cycles = 13.89 unités
	;;    8 bits = 111.1 unités
	;;    t1 = 13, t8 = 110			dt = 69

sync:
	;; R25:R24 = t0
	;; R27:R26 = t
	;; 
	ldi	R26, 0		;		t = 0
	ldi	R27, 0

	;; Measure next low-level duration in R27:R26
	;; Start counting from -1 because we add 1 right after the first falling edge
	;; 
1:
	;; dbg	1

	movw	R24, R26	;		t0 = t
	ldi	R26, 0xFF	;		t = -1
	ldi	R27, 0xFF	;
	
2:	sbis	RXDPIN, RXDBIT	;		Wait RXD == 1
	rjmp	2b		;

2:	sbic	RXDPIN, RXDBIT	; [1/2]		Wait RXD == 0
	rjmp	2b		; [2]

2:	adiw	R26, 1		; [2]	|	Compute low level duration
	sbis	RXDPIN, RXDBIT	; [1/2]	|	in 5 CPU cycles units
	rjmp	2b		; [2]	|= 5

	;; Debug info: delay
	;;
	;; .if 1
	;; SYSHZ = 8000000
	;; BAUD = 1200
	;; BTIME = (SYSHZ+BAUD/2)/BAUD
	;; DELAY = 12*BTIME
	;; ;;
	;; dbg	0
	;; ;; .fail DELAY
	;; ;; .fail (DELAY & 0xFF)
	;; ;; .fail (DELAY >> 8)
	;; movw	R28, R24	; save t0
	;; movw	R30, R26	; save t

	;; ldi	R24, lo8(DELAY)	; wait end of byte
	;; ldi	R25, hi8(DELAY)	;
	;; rcall	delay		;

	;; ldi	R24, lo8(BTIME)	; set bit duration for tx
	;; ldi	R25, hi8(BTIME)	;
	;; movw	R14, R24	;

	;; mov	R24, R28	; tx t0
	;; rcall	putbytenocrc	;
	;; mov	R24, R29	;
	;; rcall	putbytenocrc	;

	;; mov	R24, R30	; tx t
	;; rcall	putbytenocrc	;
	;; mov	R24, R31	;
	;; rcall	putbytenocrc	;

	;; movw	R26, R30	; restore t
	;; movw	R24, R28	; restore t0
	;; .endif

	movw	R28, R24	; R29:R28 = t0
	lsr	R29		;
	ror	R28		; R29:R28 = t0/2

	ldi	R20, 3		;
2:	lsl	R24		;
	rol	R25		;
	dec	R20		;
	brne	2b		; R25:R24 = 8×t0

	sub	R24, R28	;
	sbc	R25, R29	; R25:R24 = 8×t0-t0/2 = 8×(t0-t0/16)

	cp	R26, R24	; if ( t < 8×(t0-t0/16) )
	cpc	R27, R25	;   then t/t0 is too low
	brcs	1b		;   loop to get another sample

	add	R24, R28	;
	adc	R25, R29	; R25:R24 = 8×t0
	add	R24, R28	;
	adc	R25, R29	; R25:R24 = 8×t0+t0/2 = 8×(t0+t0/16)

	cp	R24, R26	; if ( 8×(t0+t0/16) < t )
	cpc	R25, R27	;   then t/t0 is too high
	brcs	1b		;   loop to get another sample

	;; we have t/t0 ~= 8 with t computed in 5 cycles units
	;; t + t/4 gives 10 bits duration in 5 cycles units
	;; (t + t/4)/2 gives 5 bits duration in 5 cycles units,
	;; i.e. 1 bit duration in 1 cycle unit
	;; 
2:	movw	R28, R26	; R29:R28 = t
	adiw	R28, 2		; round
	lsr	R29
	ror	R28		; R29:R28 = t/2
	lsr	R29
	ror	R28		; R29:R28 = t/4

	add	R28, R26
	adc	R29, R27	; R29:R28 = t + t/4

	lsr	R29
	ror	R28		; R29:R28 = (t + t/4)/2
	movw	R14, R28	; Store bit duration

	;; Debug info: duration
	;;
	.if 1
	movw	R30, R26	; save t
	mov	R24, R14
	rcall	putbytenocrc
	mov	R24, R15
	rcall	putbytenocrc
	movw	R26, R30	; restore t
	rjmp	1b
	.else

	ldi	R20, 10		; wait end of byte
1:	movw	R24, R14	;
	rcall	delay		;
	dec	R20		;
	brne	1b		;

	;; ret

	.endif
