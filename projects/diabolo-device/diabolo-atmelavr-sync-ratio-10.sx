
	;; Synchronize UART :
	;;   Measure consecutive low-level durations: say t1 and t2.
	;;   When 9.5×t2 <= t1 <= 10.5×t2, synchronization is done
	;;   and R15:R14 contains the bit duration (baudrate) in CPU cycles.
	;;
	;; Durations are measured in units of 5 cycles, so duration of 10 bits
	;; in 5 cycle units gives the duration of 2 bits in CPU cycles.
	;; 
	;; Counts overflow at 65535 units, i.e. 65535*5 cycles
	;; That means that the longest low-level duration must be < 327675 cycles
	;; and this routine can not synchronize at speeds below SYSHZ/(327675/10) bps
	;; using 10 low-level bits characters, i.e.  bps @8 MHz.
	;; 
	;;   8 MHz / 1200 bps:
	;;    1 bit = 833µs =  6667 cycles = 1333 units
	;;    10 bits =  units
	;;    t1 = 13316, t2 = 1331, t = 6658
	;; 
	;;   8 MHz / 2400 bps
	;;    1 bit = 417µs = 3333 cycles = 667 units
	;;    10 bits = 6667 units
	;;    t1 = 6658, t2 = 682, t = 3329
	;;
	;;   8 MHz / 19200 bps
	;;    1 bit = 52.1µs = 417 cycles = 83 units
	;;    10 bits = 833 units
	;;    t1 = 832, t2 = 83, t = 416
	;;
	;;   8 MHz / 115200 bps
	;;    1 bit = 8.68µs = 69.4 cycles = 13.89 units
	;;    10 bits =  units
	;;    t1 = 138, t2 = 13, t = !

;; sync:
	;; R25:R24 = t1
	;; R27:R26 = t2
	;; 
	ldi	R26, 0		;		t2 = 0
	ldi	R27, 0

	;; Measure next low-level duration in R27:R26
	;; Start counting from -1 because we add 1 right after the first falling edge
	;; 
1:
	;; dbg	1

	movw	R24, R26	;		t1 = t2
	;; ldi	R26, 0xFF	;		t2 = -1
	;; ldi	R27, 0xFF	;
	ldi	R26, 0		;		t2 = 0
	ldi	R27, 0		;
	
2:	sbis	RXDPIN, RXDBIT	;		Wait RXD == 1
	rjmp	2b		;

2:	sbic	RXDPIN, RXDBIT	; [1/2]		Wait RXD == 0
	rjmp	2b		; [2]

2:	adiw	R26, 1		; [2]	|	Compute low level duration
	sbis	RXDPIN, RXDBIT	; [1/2]	|	in 5 CPU cycles units
	rjmp	2b		; [2]	|= 5

	;; Output debug info: low-level duration in units
	;;
	.if 0
	SYSHZ = 8000000
	BAUD = 115200
	BTIME = (SYSHZ+BAUD/2)/BAUD
	DELAY = 6*BTIME
	;;
	dbg	0
	movw	R28, R24	; save t1
	movw	R30, R26	; save t2

	ldi	R24, lo8(DELAY)	; wait end of byte
	ldi	R25, hi8(DELAY)	;
	rcall	delay		;
	ldi	R24, lo8(DELAY)	; wait end of byte
	ldi	R25, hi8(DELAY)	;
	rcall	delay		;

	ldi	R24, lo8(BTIME)	; set bit duration for tx
	ldi	R25, hi8(BTIME)	;
	movw	R14, R24	;

	mov	R24, R28	; tx t1
	rcall	putbytenocrc	;
	mov	R24, R29	;
	rcall	putbytenocrc	;

	mov	R24, R30	; tx t2
	rcall	putbytenocrc	;
	mov	R24, R31	;
	rcall	putbytenocrc	;

	movw	R26, R30	; restore t2
	movw	R24, R28	; restore t1
	.endif

	;; R29:R28 = 10×t2
	;; 
	movw	R28, R26	; R29:R28 = t2
	lsl	R28		;
	rol	R29		; R29:R28 = 2×t2
	lsl	R28		;
	rol	R29		; R29:R28 = 4×t2
	add	R28, R26	;
	adc	R29, R27	; R29:R28 = 5×t2
	lsl	R28		;
	rol	R29		; R29:R28 = 10×t2

	;; R31:R30 = dt
	;; 
	movw	R30, R26	; R31:R30 = t2
	adiw	R30, 1		; round
	lsr	R31		;
	ror	R30		; R31:R30 = t2/2
	;; lsr	R31		;
	;; ror	R30		; R31:R30 = t2/4

	sub	R28, R30	;
	sbc	R29, R31	; R29:R28 = 10×t2 - dt

	cp	R24, R28	; if ( t1 < 10×t2 - dt )
	cpc	R25, R29	;   then t1 is too low
	brcs	1b		;   loop to get another sample

	add	R28, R30	;
	adc	R29, R31	; R29:R28 = 10×t2
	add	R28, R30	;
	adc	R29, R31	; R29:R28 = 10×t2 + dt

	cp	R24, R28	; if ( t1 > 10×t2 + dt )
	cpc	R25, R29	;   then t1 is too high
	brcc	1b		;   loop to get another sample

	;; we have 10×t2 - dt <= t1 <=  10×t2 + dt
	;; t1 gives ~10 bits duration in 5 cycles units
	;; t1/2 gives ~5 bits duration in 5 cycles units,
	;; i.e. 1 bit duration in 1 cycle unit
	;;
	adiw	R24, 1		; round
	lsr	R25
	ror	R24		; R25:R24 = t1/2
	movw	R14, R24	; Store bit duration

	;; Debug info: 1 bit duration in CPU cycles
	;;
	.if 0
	movw	R30, R26	; save t2
	movw	R28, R14
	ldi	R24, lo8(BTIME)	; set bit duration for tx
	ldi	R25, hi8(BTIME)	;
	movw	R14, R24	;
	mov	R24, R28
	rcall	putbytenocrc
	mov	R24, R29
	rcall	putbytenocrc
	movw	R26, R30	; restore t2
	rjmp	1b
	.endif
